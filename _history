{"entries":[{"timestamp":1751779001599,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" id=\"0!i=:.C{=iz%rgf~b)su\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever"],[0,"\"></"]],"start1":12,"start2":12,"length1":137,"length2":102},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"Onebit.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":224,"start2":224,"length1":114,"length2":44}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"Onebit.ts","value":"\n//% weight=100 color=#993366 icon=\"\\uf2db\" block=\"One:Bit\"\n//% groups='[\"Digital Pins\", \"Analog Pins\", \"Pin Events\", \"Neo_Color\", \"Setup\", \"Display\", \"Color Utilities\", \"Effects\", \"General IO\", \"Switches & Buttons\", \"Environmental\", \"Motion Sensors\", \"Proximity & Distance\", \"Analog Inputs\", \"Positional Servo\", \"Continuous Servo\", \"OLED Display\", \"IR Remote (Experimental)\"]'\nnamespace One_Bit {\n\n    // Define custom enums for digital pins\n    export enum DigitalPinPrime {\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P3\"\n        P3 = DigitalPin.P3,\n        //% block=\"P4\"\n        P4 = DigitalPin.P4,\n        //% block=\"P9\"\n        P9 = DigitalPin.P9,\n        //% block=\"P10\"\n        P10 = DigitalPin.P10,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P19\"\n        P19 = DigitalPin.P19,\n        //% block=\"P20\"\n        P20 = DigitalPin.P20\n    }\n\n    // Define custom enums for analog pins\n    export enum AnalogPinPrime {\n        //% block=\"P0\"\n        P0 = AnalogPin.P0,\n        //% block=\"P1\"\n        P1 = AnalogPin.P1,\n        //% block=\"P2\"\n        P2 = AnalogPin.P2,\n        //% block=\"P3\"\n        P3 = AnalogPin.P3,\n        //% block=\"P4\"\n        P4 = AnalogPin.P4,\n        //% block=\"P10\"\n        P10 = AnalogPin.P10\n    }\n\n    // Enum for PWM pins (often used for Servos, Ultrasonic trigger)\n    export enum PWMPin { // Renamed from PWM to avoid conflict with potential PWM functions\n        //% block=\"P0\"\n        P0 = DigitalPin.P0,\n        //% block=\"P1\"\n        P1 = DigitalPin.P1,\n        //% block=\"P2\"\n        P2 = DigitalPin.P2,\n        //% block=\"P8\"\n        P8 = DigitalPin.P8,\n        //% block=\"P12\"\n        P12 = DigitalPin.P12,\n        //% block=\"P13\"\n        P13 = DigitalPin.P13,\n        //% block=\"P14\"\n        P14 = DigitalPin.P14,\n        //% block=\"P15\"\n        P15 = DigitalPin.P15,\n        //% block=\"P16\"\n        P16 = DigitalPin.P16\n    }\n\n    export enum PinPullState {\n        //% block=\"Pull Up\"\n        PullUp = PinPullMode.PullUp,\n        //% block=\"Pull Down\"\n        PullDown = PinPullMode.PullDown,\n        //% block=\"Pull None\"\n        PullNone = PinPullMode.PullNone\n    }\n\n    export enum PinEventTypePrime {\n        //% block=\"edge (rise and fall)\"\n        Edge = DAL.MICROBIT_PIN_EVENT_ON_EDGE, // Correct DAL constant\n        //% block=\"pulse\"\n        Pulse = DAL.MICROBIT_PIN_EVENT_ON_PULSE, // Correct DAL constant\n        //% block=\"rise\"\n        Rise = DAL.MICROBIT_PIN_EVENT_ON_TOUCH, // Often used for rise, or map to Edge and filter\n        //% block=\"fall\"\n        Fall = DAL.MICROBIT_PIN_EVENT_ON_TOUCH, // Often used for fall, or map to Edge and filter\n        //% block=\"none\"\n        None = DAL.MICROBIT_PIN_EVENT_NONE // Correct DAL constant\n    }\n\n\n    ////////////////////\n    //  PRIME BLOCKS  // (General Pin I/O & P16 NeoPixel)\n    ////////////////////\n\n    /**\n     * Read digital value from a specific pin.\n     * @param pin The digital pin to read from.\n     * @returns The digital value (0 or 1) read from the pin.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=100 blockGap=8\n    //% blockId=\"one_bit_digital_read\" block=\"read digital pin %pin\"\n    export function digitalRead(pin: DigitalPinPrime): number {\n        return pins.digitalReadPin(pin as number as DigitalPin);\n    }\n\n    /**\n     * Write a digital value to a specific pin.\n     * @param pin The digital pin to write to.\n     * @param value The digital value (0 or 1) to write.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=95 blockGap=8\n    //% blockId=\"one_bit_digital_write\" block=\"write digital pin %pin to %value\"\n    //% value.min=0 value.max=1\n    export function digitalWrite(pin: DigitalPinPrime, value: number): void {\n        pins.digitalWritePin(pin as number as DigitalPin, value);\n    }\n\n    /**\n     * Check if a digital pin is HIGH.\n     * @param pin The digital pin to check.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=90 blockGap=8\n    //% blockId=\"one_bit_is_pin_high\" block=\"is pin %pin HIGH\"\n    export function isPinHigh(pin: DigitalPinPrime): boolean {\n        return pins.digitalReadPin(pin as number as DigitalPin) === 1;\n    }\n\n    /**\n     * Check if a digital pin is LOW.\n     * @param pin The digital pin to check.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=85 blockGap=8\n    //% blockId=\"one_bit_is_pin_low\" block=\"is pin %pin LOW\"\n    export function isPinLow(pin: DigitalPinPrime): boolean {\n        return pins.digitalReadPin(pin as number as DigitalPin) === 0;\n    }\n\n    /**\n     * Set the pull mode for a digital pin.\n     * @param pin The digital pin to configure.\n     * @param pull The pull mode (Up, Down, None).\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Digital Pins\"\n    //% weight=80 blockGap=30\n    //% blockId=\"one_bit_set_pin_pull\" block=\"set pin %pin to %pull\"\n    export function setPinPull(pin: DigitalPinPrime, pull: PinPullState): void {\n        pins.setPull(pin as number as DigitalPin, pull as number as PinPullMode);\n    }\n\n    /**\n     * Read analog value from a specific pin.\n     * @param pin The analog pin to read from.\n     * @returns The analog value (0-1023) read from the pin.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=75 blockGap=8\n    //% blockId=\"one_bit_analog_read\" block=\"read analog pin %pin\"\n    export function analogRead(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin as number as AnalogPin);\n    }\n\n    /**\n     * Write an analog value (PWM) to a specific pin.\n     * @param pin The pin to write to (must be PWM capable).\n     * @param value The analog value (0-1023) to write.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=70 blockGap=8\n    //% blockId=\"one_bit_analog_write\" block=\"write analog pin %pin to %value\"\n    //% value.min=0 value.max=1023\n    export function analogWrite(pin: AnalogPinPrime, value: number): void {\n        pins.analogWritePin(pin as number as AnalogPin, value);\n    }\n\n    /**\n     * Map an analog sensor reading from its original range [0-1023] to a new range.\n     * @param value The analog value to map (0-1023).\n     * @param toLow The lower bound of the target range.\n     * @param toHigh The upper bound of the target range.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=65 blockGap=8\n    //% blockId=\"one_bit_map_analog\" block=\"map analog value %value from [0-1023] to [%toLow-%toHigh]\"\n    //% value.shadow=\"one_bit_analog_read\"\n    export function mapAnalog(value: number, toLow: number, toHigh: number): number {\n        return Math.map(value, 0, 1023, toLow, toHigh);\n    }\n\n    /**\n     * Map an analog sensor reading from its original range [0-1023] to a percentage [0-100].\n     * @param value The analog value to map (0-1023).\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Analog Pins\"\n    //% weight=60 blockGap=30\n    //% blockId=\"one_bit_map_analog_to_percent\" block=\"map analog value %value to percentage [0-100]\"\n    //% value.shadow=\"one_bit_analog_read\"\n    export function mapAnalogToPercent(value: number): number {\n        return Math.map(value, 0, 1023, 0, 100);\n    }\n\n\n    /**\n     * Register an event handler for a pin event.\n     * @param pin The pin to monitor.\n     * @param type The type of event to listen for.\n     * @param handler Code to run when the event occurs.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Pin Events\"\n    //% weight=55 blockGap=8\n    //% blockId=\"one_bit_on_pin_event\" block=\"on pin %pin event %type\"\n    export function onPinEvent(pin: DigitalPinPrime, type: PinEventTypePrime, handler: () => void): void {\n        const targetPin = pin as number as DigitalPin;\n\n        if (type === PinEventTypePrime.Rise) {\n            pins.onPulsed(targetPin, PulseValue.High, handler);\n        } else if (type === PinEventTypePrime.Fall) {\n            pins.onPulsed(targetPin, PulseValue.Low, handler);\n        } else if (type === PinEventTypePrime.Edge) {\n            // DAL.MICROBIT_PIN_EVENT_ON_EDGE corresponds to PinEventType.Edge\n            pins.setEvents(targetPin, PinEventType.Edge);\n            control.onEvent(getPinEventSource(targetPin), DAL.MICROBIT_PIN_EVENT_ON_EDGE, handler);\n        } else if (type === PinEventTypePrime.Pulse) {\n            // DAL.MICROBIT_PIN_EVENT_ON_PULSE corresponds to PinEventType.Pulse\n            pins.setEvents(targetPin, PinEventType.Pulse);\n            control.onEvent(getPinEventSource(targetPin), DAL.MICROBIT_PIN_EVENT_ON_PULSE, handler);\n        } else if (type === PinEventTypePrime.None) {\n            // Typically, you wouldn't register a handler for \"None\", but clear existing ones.\n            // For simplicity, this block structure might not support clearing specific handlers easily.\n            // This will effectively do nothing if \"None\" is selected for a new event.\n            pins.setEvents(targetPin, PinEventType.None);\n        }\n    }\n\n\n    // Helper to get the event source for a pin\n    function getPinEventSource(pin: DigitalPin): EventBusSource {\n        switch (pin) {\n            case DigitalPin.P0: return EventBusSource.MICROBIT_ID_IO_P0;\n            case DigitalPin.P1: return EventBusSource.MICROBIT_ID_IO_P1;\n            case DigitalPin.P2: return EventBusSource.MICROBIT_ID_IO_P2;\n            case DigitalPin.P3: return EventBusSource.MICROBIT_ID_IO_P3;\n            case DigitalPin.P4: return EventBusSource.MICROBIT_ID_IO_P4;\n            case DigitalPin.P9: return EventBusSource.MICROBIT_ID_IO_P9;\n            case DigitalPin.P10: return EventBusSource.MICROBIT_ID_IO_P10;\n            case DigitalPin.P13: return EventBusSource.MICROBIT_ID_IO_P13;\n            case DigitalPin.P14: return EventBusSource.MICROBIT_ID_IO_P14;\n            case DigitalPin.P15: return EventBusSource.MICROBIT_ID_IO_P15;\n            case DigitalPin.P19: return EventBusSource.MICROBIT_ID_IO_P19;\n            case DigitalPin.P20: return EventBusSource.MICROBIT_ID_IO_P20;\n            default: return EventBusSource.MICROBIT_ID_IO_P0; // Fallback\n        }\n    }\n\n\n    // --- Prime NeoPixel ---\n    let primeBuffer: Buffer = null;\n    let primeNumLeds: number = 12;\n    let primeBrightness: number = 255;\n    let primeLastBrightnessApplied: number = 255;\n    let primeRawColors: number[] = []; // Store colors before brightness\n\n    /**\n     * Initialize the Prime LED strip (connected to P16).\n     * @param numLeds The number of LEDs in the strip.\n     */\n    //% subcategory=\"Prime\"\n    //% group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_initialize\" block=\"initialize Prime NeoPixel with %numLeds LEDs\"\n    //% weight=100 blockGap=8 numLeds.defl=12\n    export function initializePrime(numLeds: number): void {\n        primeNumLeds = Math.max(1, numLeds);\n        primeBuffer = control.createBuffer(primeNumLeds * 3);\n        primeRawColors = [];\n        for (let i = 0; i < primeNumLeds; i++) primeRawColors.push(0);\n        primeBrightness = 255;\n        primeLastBrightnessApplied = 255;\n        clearPrime();\n    }\n\n    function _primeEnsureInitialized() {\n        if (!primeBuffer) initializePrime(primeNumLeds);\n    }\n\n    function _primeApplyBrightnessToRaw(index: number, color: number): void {\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n        primeBuffer[index * 3 + 0] = Math.round((g * primeBrightness) / 255);\n        primeBuffer[index * 3 + 1] = Math.round((r * primeBrightness) / 255);\n        primeBuffer[index * 3 + 2] = Math.round((b * primeBrightness) / 255);\n    }\n\n    function _primeSetLedColorRaw(index: number, red: number, green: number, blue: number): void {\n        _primeEnsureInitialized();\n        if (index < 0 || index >= primeNumLeds) return;\n        let color = (red << 16) | (green << 8) | blue;\n        primeRawColors[index] = color;\n        _primeApplyBrightnessToRaw(index, color);\n    }\n\n    function showPrimeBuffer(): void {\n        _primeEnsureInitialized();\n        light.sendWS2812Buffer(primeBuffer, DigitalPin.P16);\n    }\n\n    /**\n     * Show rainbow colors on the Prime strip.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_show_rainbow\" block=\"Prime show rainbow\"\n    //% weight=95 blockGap=8\n    export function showPrime(): void {\n        _primeEnsureInitialized();\n        for (let i = 0; i < primeNumLeds; i++) {\n            let hue = (i * 360) / primeNumLeds;\n            const color = hslToRgb(hue, 100, 50);\n            primeRawColors[i] = color;\n            _primeApplyBrightnessToRaw(i, color);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Clear all LEDs on the Prime strip.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_clear\" block=\"Prime clear\"\n    //% weight=90 blockGap=8\n    export function clearPrime(): void {\n        _primeEnsureInitialized();\n        for (let i = 0; i < primeNumLeds; i++) {\n            primeRawColors[i] = 0;\n            _primeApplyBrightnessToRaw(i, 0);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Set color of all LEDs on the Prime strip.\n     * @param color The color to set.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\" value.defl='#ff0000'\n    //% blockId=\"one_bit_prime_set_color_all\" block=\"Prime set all LEDs to %color\"\n    //% weight=85 blockGap=8 color.shadow=\"one_bit_prime_color_picker\"\n    export function setPrimeColor(color: number): void {\n        _primeEnsureInitialized();\n        for (let i = 0; i < primeNumLeds; i++) {\n            primeRawColors[i] = color;\n            _primeApplyBrightnessToRaw(i, color);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Set color of a specific LED on the Prime strip.\n     * @param ledIndex The index of the LED to change (0-based).\n     * @param color The color to set.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\" value.defl='#FFFFFF'\n    //% blockId=\"one_bit_prime_set_led_color\" block=\"Prime set LED at %ledIndex to %color\"\n    //% weight=80 blockGap=8 ledIndex.min=0 color.shadow=\"one_bit_prime_color_picker\"\n    export function setPrimeLedColor(ledIndex: number, color: number): void {\n        _primeEnsureInitialized();\n        if (ledIndex < 0 || ledIndex >= primeNumLeds) return;\n        primeRawColors[ledIndex] = color;\n        _primeApplyBrightnessToRaw(ledIndex, color);\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Get the color of a specific LED on the Prime strip (as set, before brightness).\n     * @param ledIndex The index of the LED (0-based).\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_get_led_color\" block=\"Prime get color of LED at %ledIndex\"\n    //% weight=78 blockGap=8 ledIndex.min=0\n    export function getPrimeLedColor(ledIndex: number): number {\n        _primeEnsureInitialized();\n        if (ledIndex < 0 || ledIndex >= primeNumLeds) return 0;\n        return primeRawColors[ledIndex];\n    }\n\n    /**\n     * Fill a range of LEDs on the Prime strip with a color.\n     * @param fromIndex Start index of the range (0-based).\n     * @param toIndex End index of the range (inclusive).\n     * @param color The color to set.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\" value.defl='#00FF00'\n    //% blockId=\"one_bit_prime_fill_leds\" block=\"Prime fill LEDs from %fromIndex to %toIndex with %color\"\n    //% weight=77 blockGap=8 color.shadow=\"one_bit_prime_color_picker\"\n    //% fromIndex.min=0 toIndex.min=0\n    export function fillPrimeLeds(fromIndex: number, toIndex: number, color: number): void {\n        _primeEnsureInitialized();\n        fromIndex = Math.clamp(0, primeNumLeds - 1, fromIndex);\n        toIndex = Math.clamp(0, primeNumLeds - 1, toIndex);\n        for (let i = Math.min(fromIndex, toIndex); i <= Math.max(fromIndex, toIndex); i++) {\n            primeRawColors[i] = color;\n            _primeApplyBrightnessToRaw(i, color);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n\n    /**\n     * Set brightness of the Prime strip.\n     * @param brightness Brightness level (0-255).\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_set_brightness\" block=\"Prime set brightness to %brightness\"\n    //% weight=75 blockGap=8 brightness.min=0 brightness.max=255 brightness.defl=255\n    export function setPrimeBrightness(brightness: number): void {\n        _primeEnsureInitialized();\n        primeBrightness = Math.clamp(0, 255, brightness);\n        for (let i = 0; i < primeNumLeds; i++) {\n            _primeApplyBrightnessToRaw(i, primeRawColors[i]);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Shift LEDs on the Prime strip by a number of positions.\n     * @param offset Number of positions to shift (positive for right, negative for left).\n     * @param wrapAround If true, LEDs shifted off one end reappear on the other.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_shift_leds\" block=\"Prime shift LEDs by %offset positions || wrap around %wrapAround\"\n    //% weight=73 blockGap=8 wrapAround.defl=false\n    export function shiftPrimeLeds(offset: number, wrapAround: boolean = false): void {\n        _primeEnsureInitialized();\n        if (primeNumLeds === 0 || offset === 0) return;\n\n        offset = offset % primeNumLeds;\n        let newRawColors = [];\n\n        for (let i = 0; i < primeNumLeds; i++) {\n            let sourceIndex = i - offset;\n            if (wrapAround) {\n                sourceIndex = (sourceIndex % primeNumLeds + primeNumLeds) % primeNumLeds; // Handles negative results\n                newRawColors.push(primeRawColors[sourceIndex]);\n            } else {\n                if (sourceIndex >= 0 && sourceIndex < primeNumLeds) {\n                    newRawColors.push(primeRawColors[sourceIndex]);\n                } else {\n                    newRawColors.push(0); // Fill with black if out of bounds\n                }\n            }\n        }\n        primeRawColors = newRawColors;\n        for (let i = 0; i < primeNumLeds; i++) {\n            _primeApplyBrightnessToRaw(i, primeRawColors[i]);\n        }\n        showPrimeBuffer();\n    }\n\n    /**\n     * Rotate LEDs on the Prime strip by a number of positions (always wraps around).\n     * @param offset Number of positions to rotate (positive for right, negative for left).\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_rotate_leds\" block=\"Prime rotate LEDs by %offset positions\"\n    //% weight=72 blockGap=8\n    export function rotatePrimeLeds(offset: number): void {\n        shiftPrimeLeds(offset, true);\n    }\n\n    /**\n     * Show a gradient pattern on the Prime strip.\n     * @param startHue The starting hue value (0-360). (Currently not used in this blend mode)\n     * @param length The number of LEDs to fill with the gradient.\n     * @param fromColor Starting color of the gradient.\n     * @param toColor Ending color of the gradient.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_gradient\" block=\"Prime show gradient length %length|from %fromColor|to %toColor||start hue %startHue\"\n    //% weight=70 blockGap=8 length.defl=12\n    //% fromColor.shadow=\"one_bit_prime_color_picker\" value.defl=\"#ff0000\"\n    //% toColor.shadow=\"one_bit_prime_color_picker\" value.defl=\"#0000ff\"\n    //% startHue.min=0 startHue.max=360\n    export function showPrimeGradient(length: number, fromColor: number, toColor: number, startHue?: number): void {\n        _primeEnsureInitialized();\n        length = Math.min(length, primeNumLeds);\n\n        if (length === 0) { showPrimeBuffer(); return; }\n\n        for (let i = 0; i < length; i++) {\n            let blendFactor = (length <= 1) ? 0 : i / (length - 1);\n            let RblendColor = blend(fromColor, toColor, blendFactor);\n            primeRawColors[i] = RblendColor;\n            _primeApplyBrightnessToRaw(i, RblendColor);\n        }\n        // Fill remaining LEDs with black if gradient length < total LEDs\n        for (let i = length; i < primeNumLeds; i++) {\n            primeRawColors[i] = 0;\n            _primeApplyBrightnessToRaw(i, 0);\n        }\n        primeLastBrightnessApplied = primeBrightness;\n        showPrimeBuffer();\n    }\n\n    /**\n     * Helper function to blend two colors.\n     * @param color1 The first color.\n     * @param color2 The second color.\n     * @param factor The blend factor (0-1). 0 means color1, 1 means color2.\n     */\n    function blend(color1: number, color2: number, factor: number): number {\n        factor = Math.clamp(0, 1, factor);\n        let r1 = (color1 >> 16) & 0xFF; let g1 = (color1 >> 8) & 0xFF; let b1 = color1 & 0xFF;\n        let r2 = (color2 >> 16) & 0xFF; let g2 = (color2 >> 8) & 0xFF; let b2 = color2 & 0xFF;\n        let r = Math.round(r1 * (1 - factor) + r2 * factor);\n        let g = Math.round(g1 * (1 - factor) + g2 * factor);\n        let b = Math.round(b1 * (1 - factor) + b2 * factor);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Prime color picker.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% weight=65 blockGap=20 blockId=\"one_bit_prime_color_picker\" block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#FF0000\", \"#FFA500\", \"#FFFF00\", \"#7FFF00\", \"#00FF00\", \"#00FFFF\", \"#007FFF\", \"#0000FF\", \"#A000FF\", \"#FF00FF\", \"#FF1493\", \"#A0522D\", \"#FFFFFF\", \"#808080\", \"#000000\"]'\n    //% value.fieldOptions.columns=5 value.fieldOptions.className='rgbColorPicker'\n    export function __primeColorNumberPicker(value: number): number {\n        return value;\n    }\n\n    /**\n     * Get a random color.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_random_color\" block=\"Prime random color\" weight=60\n    export function primeRandomColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n    /**\n     * Convert RGB values to a color number.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_rgb_to_color\" block=\"Prime R %r G %g B %b\" weight=55\n    //% r.min=0 r.max=255 g.min=0 g.max=255 b.min=0 b.max=255\n    export function primeRgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL values to a color number.\n     */\n    //% subcategory=\"Prime\" group=\"Neo_Color\"\n    //% blockId=\"one_bit_prime_hsl_to_color\" block=\"Prime hue %h saturation %s luminosity %l\" weight=50\n    //% h.min=0 h.max=360 s.min=0 s.max=100 l.min=0 l.max=100\n    export function primeHslToColor(h: number, s: number, l: number): number {\n        return hslToRgb(h, s, l);\n    }\n\n    function hslToRgb(h: number, s: number, l: number): number {\n        h = h % 360;\n        s = Math.clamp(0, 100, s) / 100;\n        l = Math.clamp(0, 100, l) / 100;\n        const c = (1 - Math.abs(2 * l - 1)) * s;\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        const m = l - c / 2;\n        let r = 0, g = 0, b = 0;\n        if (h < 60) { r = c; g = x; b = 0; }\n        else if (h < 120) { r = x; g = c; b = 0; }\n        else if (h < 180) { r = 0; g = c; b = x; }\n        else if (h < 240) { r = 0; g = x; b = c; }\n        else if (h < 300) { r = x; g = 0; b = c; }\n        else { r = c; g = 0; b = x; }\n        const red = Math.round((r + m) * 255);\n        const green = Math.round((g + m) * 255);\n        const blue = Math.round((b + m) * 255);\n        return (red << 16) | (green << 8) | blue;\n    }\n\n    ////////////////////\n    // SENSORS        //\n    ////////////////////\n\n    export enum DistanceUnit {\n        //% block=\"cm\"\n        CM,\n        //% block=\"inches\"\n        INCH\n    }\n\n    /**\n     * Get distance from HC-SR04 ultrasonic sensor.\n     * @param trigPin TRIG pin of the sensor.\n     * @param echoPin ECHO pin of the sensor.\n     * @param unit Desired distance unit.\n     * @param maxCmDistance Maximum measurable distance in cm (default 500).\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"Ultrasonic\"\n    //% blockId=\"one_bit_ultrasonic_distance\"\n    //% block=\"ultrasonic distance trig %trigPin echo %echoPin unit %unit\"\n    //% trigPin.defl=PWMPin.P0 echoPin.defl=PWMPin.P1 unit.defl=DistanceUnit.CM\n    //% weight=100 blockGap=8\n    export function getUltrasonicDistance(trigPin: PWMPin, echoPin: PWMPin, unit: DistanceUnit, maxCmDistance = 500): number {\n        pins.setPull(trigPin as number as DigitalPin, PinPullMode.PullNone);\n        pins.digitalWritePin(trigPin as number as DigitalPin, 0); control.waitMicros(2);\n        pins.digitalWritePin(trigPin as number as DigitalPin, 1); control.waitMicros(10);\n        pins.digitalWritePin(trigPin as number as DigitalPin, 0);\n        const d = pins.pulseIn(echoPin as number as DigitalPin, PulseValue.High, maxCmDistance * 58);\n        if (d === 0) return -1; // No echo\n        switch (unit) {\n            case DistanceUnit.CM: return Math.idiv(d, 58);\n            case DistanceUnit.INCH: return Math.idiv(d, 148);\n            default: return -1;\n        }\n    }\n\n\n    // --- DHT11 Sensor ---\n    export enum TemperatureUnit {\n        //% block=\"Celsius (*C)\"\n        Celsius,\n        //% block=\"Fahrenheit (*F)\"\n        Fahrenheit,\n    }\n    let _dht11Temperature: number = -999.0;\n    let _dht11Humidity: number = -999.0;\n    let _dht11LastReadTime: number = 0;\n\n    function _queryDHT11Data(pin: DigitalPin): void {\n        if (input.runningTime() - _dht11LastReadTime < 1800) return; // Min 2s interval\n        _dht11LastReadTime = input.runningTime();\n        // Implementation from previous response (assumed correct)\n        let resultArray: number[] = [0, 0, 0, 0, 0]; let dataArray: boolean[] = [];\n        for (let i = 0; i < 40; i++) dataArray.push(false);\n        pins.digitalWritePin(pin, 0); basic.pause(18);\n        pins.setPull(pin, PinPullMode.PullUp); pins.digitalReadPin(pin); control.waitMicros(40);\n        if (pins.digitalReadPin(pin) == 0) {\n            while (pins.digitalReadPin(pin) == 0); while (pins.digitalReadPin(pin) == 1);\n            for (let i = 0; i < 40; i++) {\n                while (pins.digitalReadPin(pin) == 0); control.waitMicros(28);\n                if (pins.digitalReadPin(pin) == 1) dataArray[i] = true;\n                while (pins.digitalReadPin(pin) == 1);\n            }\n            for (let i = 0; i < 5; i++) for (let j = 0; j < 8; j++) if (dataArray[8 * i + j]) resultArray[i] += 2 ** (7 - j);\n            let checksum = (resultArray[0] + resultArray[1] + resultArray[2] + resultArray[3]) & 0xFF;\n            if (checksum === resultArray[4]) {\n                _dht11Humidity = resultArray[0] + resultArray[1] / 100;\n                _dht11Temperature = resultArray[2] + resultArray[3] / 100;\n            } else { _dht11Humidity = -998; _dht11Temperature = -998; } // Checksum error\n        } else { _dht11Humidity = -997; _dht11Temperature = -997; } // No response\n    }\n\n    /**\n     * Read temperature from DHT11 sensor.\n     * Returns -997 (no response), -998 (checksum error), or temperature.\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"  DHT11\"\n    //% blockId=\"one_bit_dht11_temperature\" block=\"DHT11 temperature on pin %pin in %unit\"\n    //% pin.defl=DigitalPinPrime.P2 unit.defl=TemperatureUnit.Celsius\n    //% weight=90 blockGap=8\n    export function readDHT11Temperature(pin: DigitalPinPrime, unit: TemperatureUnit): number {\n        _queryDHT11Data(pin as number as DigitalPin);\n        if (_dht11Temperature <= -997) return _dht11Temperature;\n        return unit === TemperatureUnit.Fahrenheit ? _dht11Temperature * 9 / 5 + 32 : _dht11Temperature;\n    }\n\n    /**\n     * Read humidity from DHT11 sensor.\n     * Returns -997 (no response), -998 (checksum error), or humidity %.\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"  DHT11\"\n    //% blockId=\"one_bit_dht11_humidity\" block=\"DHT11 humidity on pin %pin\"\n    //% pin.defl=DigitalPinPrime.P2\n    //% weight=88 blockGap=20\n    export function readDHT11Humidity(pin: DigitalPinPrime): number {\n        _queryDHT11Data(pin as number as DigitalPin);\n        return _dht11Humidity;\n    }\n\n    // --- DHT20 I2C Sensor ---\n    let _dht20Initialized = false; const DHT20_ADDRESS = 0x38;\n    let _dht20Temperature: number = -999.0; let _dht20Humidity: number = -999.0;\n    let _dht20LastReadTime: number = 0;\n\n    function dht20Crc(data: Buffer, len: number): number {\n        let crc = 0xFF; for (let i = 0; i < len; i++) { crc ^= data[i]; for (let j = 0; j < 8; j++) { if (crc & 0x80) crc = (crc << 1) ^ 0x31; else crc <<= 1; } } return crc & 0xFF;\n    }\n\n    function _initDHT20(): void {\n        if (_dht20Initialized) return; basic.pause(100);\n        pins.i2cWriteNumber(DHT20_ADDRESS, 0x71, NumberFormat.UInt8BE, false); let status = pins.i2cReadNumber(DHT20_ADDRESS, NumberFormat.UInt8BE, false);\n        if ((status & 0x08) === 0) { let initCmd = pins.createBuffer(3); initCmd[0] = 0xBE; initCmd[1] = 0x08; initCmd[2] = 0x00; pins.i2cWriteBuffer(DHT20_ADDRESS, initCmd); basic.pause(20); }\n        _dht20Initialized = true; _dht20LastReadTime = 0;\n    }\n\n    function _queryDHT20Data(): void {\n        if (!_dht20Initialized) _initDHT20();\n        if (input.runningTime() - _dht20LastReadTime < 1800) return;\n        let triggerCmd = pins.createBuffer(3); triggerCmd[0] = 0xAC; triggerCmd[1] = 0x33; triggerCmd[2] = 0x00;\n        pins.i2cWriteBuffer(DHT20_ADDRESS, triggerCmd); basic.pause(80);\n        let data = pins.i2cReadBuffer(DHT20_ADDRESS, 7);\n        if ((data[0] & 0x80) || !(data[0] & 0x08)) { _dht20Temperature = -998.0; _dht20Humidity = -998.0; _dht20LastReadTime = input.runningTime(); return; }\n        if (dht20Crc(data, 6) !== data[6]) { _dht20Temperature = -997.0; _dht20Humidity = -997.0; _dht20LastReadTime = input.runningTime(); return; }\n        let rawHumidity = (data[1] << 12) | (data[2] << 4) | (data[3] >>> 4);\n        let rawTemp = ((data[3] & 0x0F) << 16) | (data[4] << 8) | data[5];\n\n        // Convert humidity to an analog-style value from 0-1023 instead of a percentage\n        _dht20Humidity = (rawHumidity / Math.pow(2, 20)) * 1023;\n\n        _dht20Temperature = (rawTemp / Math.pow(2, 20)) * 200 - 50;\n        _dht20LastReadTime = input.runningTime();\n    }\n\n    /** \n     * Read temperature from DHT20 I2C sensor. \n     * Returns the temperature as a whole number.\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"DHT20 (I2C)\"\n    //% blockId=\"one_bit_dht20_temperature\" block=\"DHT20 temperature in %unit\"\n    //% unit.defl=TemperatureUnit.Celsius weight=86 blockGap=8\n    export function readDHT20Temperature(unit: TemperatureUnit): number {\n        _queryDHT20Data();\n        if (_dht20Temperature <= -997) return _dht20Temperature;\n\n        let temp = unit === TemperatureUnit.Fahrenheit ? _dht20Temperature * 9 / 5 + 32 : _dht20Temperature;\n        return Math.round(temp);\n    }\n\n    /** \n     * Read humidity from DHT20 I2C sensor.\n     * Returns the humidity as an analog-style value (0-1023).\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"DHT20 (I2C)\"\n    //% blockId=\"one_bit_dht20_humidity\" block=\"DHT20 humidity value\"\n    //% weight=84 blockGap=20\n    export function readDHT20Humidity(): number {\n        _queryDHT20Data();\n        if (_dht20Humidity <= -997) return _dht20Humidity;\n        return Math.round(_dht20Humidity);\n    }\n\n\n\n    // --- IR Obstacle Sensor ---\n    const IR_OBSTACLE_EVENT_ID = 3000;\n    const IR_OBSTACLE_DETECTED = 1;\n    const IR_OBSTACLE_CLEARED = 2;\n    // The pin being monitored is now an AnalogPin.\n    let _irObstaclePin: AnalogPinPrime = null;\n    let _irObstacleLastState = false;\n\n    // The background monitoring function. It uses the new analog-based detection.\n    function monitorIRObstacle() {\n        if (_irObstaclePin === null) return;\n        // The check now uses the analog value.\n        let currentState = readIRObstacleDetected(_irObstaclePin);\n        if (currentState !== _irObstacleLastState) {\n            _irObstacleLastState = currentState;\n            if (currentState) {\n                control.raiseEvent(IR_OBSTACLE_EVENT_ID, IR_OBSTACLE_DETECTED);\n            } else {\n                control.raiseEvent(IR_OBSTACLE_EVENT_ID, IR_OBSTACLE_CLEARED);\n            }\n        }\n    }\n\n    /**\n     * Check if IR obstacle sensor detects an object based on an analog threshold.\n     * Returns true if the analog value is less than 900.\n     * @param pin The analog pin for the IR sensor.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Sensor\"\n    //% blockId=\"one_bit_ir_obstacle_detected\" block=\"IR obstacle detected on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0 weight=80 blockGap=8\n    export function readIRObstacleDetected(pin: AnalogPinPrime): boolean {\n        // Reads the analog value and compares it to the threshold.\n        return pins.analogReadPin(pin as number as AnalogPin) < 900;\n    }\n\n    /**\n     * Get the raw analog value from the IR obstacle sensor (0-1023).\n     * @param pin The analog pin for the IR sensor.\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"IR Sensor\"\n    //% blockId=\"one_bit_ir_obstacle_analog\" block=\"IR obstacle sensor analog value on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0 weight=78 blockGap=8\n    export function readIRObstacleAnalog(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin as number as AnalogPin);\n    }\n\n    /**\n     * Event when an IR obstacle is detected (analog value goes below 900).\n     * @param pin The analog pin for the IR sensor.\n     * @param handler Code to run.\n     */\n    //% subcategory=\"Sensors\" \n    //% group=\"IR Sensor\"\n    //% blockId=\"one_bit_on_ir_obstacle_detected\" block=\"on IR obstacle detected on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0 weight=77\n    export function onIRObstacleDetected(pin: AnalogPinPrime, handler: () => void) {\n        // Only set up the background task once.\n        if (_irObstaclePin === null) {\n            _irObstaclePin = pin;\n            _irObstacleLastState = readIRObstacleDetected(pin);\n            control.inBackground(() => { while (true) { monitorIRObstacle(); basic.pause(50); } });\n        } else if (_irObstaclePin !== pin) {\n            console.warn(\"IR Obstacle event already registered on a different pin.\");\n        }\n        // Register the user's code to run for the \"DETECTED\" event.\n        control.onEvent(IR_OBSTACLE_EVENT_ID, IR_OBSTACLE_DETECTED, handler);\n    }\n\n    /**\n    * Event when an IR obstacle is cleared (analog value goes >= 900).\n    * @param pin The analog pin for the IR sensor.\n    * @param handler Code to run.\n    */\n    //% subcategory=\"Sensors\" \n    //% group=\"IR Sensor\"\n    //% blockId=\"one_bit_on_ir_obstacle_cleared\" block=\"on IR obstacle cleared on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0 weight=76 blockGap=20\n    export function onIRObstacleCleared(pin: AnalogPinPrime, handler: () => void) {\n        // Set up the background task if it's not already running.\n        if (_irObstaclePin === null) {\n            _irObstaclePin = pin;\n            _irObstacleLastState = readIRObstacleDetected(pin);\n            control.inBackground(() => { while (true) { monitorIRObstacle(); basic.pause(50); } });\n        } else if (_irObstaclePin !== pin) {\n            console.warn(\"IR Obstacle event already registered on a different pin.\");\n        }\n        // Register the user's code to run for the \"CLEARED\" event.\n        control.onEvent(IR_OBSTACLE_EVENT_ID, IR_OBSTACLE_CLEARED, handler);\n    }\n\n    export enum IrButton {\n        //% block=\"Any\"\n        Any = -1,\n        //% block=\"▲\"\n        Up = 0x46,\n        //% block=\"▼\"\n        Down = 0x15,\n        //% block=\"◀\"\n        Left = 0x44,\n        //% block=\"▶\"\n        Right = 0x43,\n        //% block=\"OK\"\n        Ok = 0x40,\n        //% block=\"*\"\n        Star = 0x42,\n        //% block=\"#\"\n        Hash = 0x52,\n        //% block=\"0\"\n        Number_0 = 0x5a,\n        //% block=\"1\"\n        Number_1 = 0x16,\n        //% block=\"2\"\n        Number_2 = 0x19,\n        //% block=\"3\"\n        Number_3 = 0x0d,\n        //% block=\"4\"\n        Number_4 = 0x0c,\n        //% block=\"5\"\n        Number_5 = 0x18,\n        //% block=\"6\"\n        Number_6 = 0x5e,\n        //% block=\"7\"\n        Number_7 = 0x08,\n        //% block=\"8\"\n        Number_8 = 0x1c,\n        //% block=\"9\"\n        Number_9 = 0x52 // Note: Can be same as Hash on some remotes\n    }\n\n    let irState: IrState;\n\n    const IR_REPEAT = 256;\n    const IR_INCOMPLETE = 257;\n    const IR_DATAGRAM = 258;\n    const REPEAT_TIMEOUT_MS = 120;\n\n    interface IrState {\n        protocol: number;\n        hasNewDatagram: boolean;\n        bitsReceived: uint8;\n        addressSectionBits: uint16;\n        commandSectionBits: uint16;\n        hiword: uint16;\n        loword: uint16;\n        activeCommand: number;\n        repeatTimeout: number;\n        onIrDatagram: () => void;\n    }\n\n    function appendBitToDatagram(bit: number): number {\n        irState.bitsReceived += 1;\n        if (irState.bitsReceived <= 16) {\n            irState.hiword = (irState.hiword << 1) + bit;\n        } else if (irState.bitsReceived <= 32) {\n            irState.loword = (irState.loword << 1) + bit;\n        }\n\n        if (irState.bitsReceived === 32) {\n            irState.addressSectionBits = irState.hiword & 0xffff;\n            irState.commandSectionBits = irState.loword & 0xffff;\n            return IR_DATAGRAM;\n        } else {\n            return IR_INCOMPLETE;\n        }\n    }\n\n    function decode(markAndSpace: number): number {\n        if (markAndSpace < 1600) { return appendBitToDatagram(0); }\n        else if (markAndSpace < 2700) { return appendBitToDatagram(1); }\n        irState.bitsReceived = 0;\n        if (markAndSpace < 12500) { return IR_REPEAT; }\n        else if (markAndSpace < 14500) { return IR_INCOMPLETE; }\n        else { return IR_INCOMPLETE; }\n    }\n\n    function enableIrMarkSpaceDetection(pin: DigitalPin) {\n        pins.setPull(pin, PinPullMode.PullNone);\n        let mark = 0;\n        let space = 0;\n        pins.onPulsed(pin, PulseValue.Low, () => { mark = pins.pulseDuration(); });\n        pins.onPulsed(pin, PulseValue.High, () => {\n            space = pins.pulseDuration();\n            const status = decode(mark + space);\n            if (status !== IR_INCOMPLETE) { handleIrEvent(status); }\n        });\n    }\n\n    function handleIrEvent(irEvent: number) {\n        if (irEvent === IR_DATAGRAM || irEvent === IR_REPEAT) {\n            irState.repeatTimeout = input.runningTime() + REPEAT_TIMEOUT_MS;\n        }\n\n        if (irEvent === IR_DATAGRAM) {\n            irState.hasNewDatagram = true;\n            if (irState.onIrDatagram) { control.inBackground(irState.onIrDatagram); }\n            irState.activeCommand = irState.commandSectionBits >> 8;\n        }\n    }\n\n    function initIrState() {\n        if (irState) return;\n        irState = {\n            protocol: 0,\n            hasNewDatagram: false,\n            bitsReceived: 0,\n            addressSectionBits: 0,\n            commandSectionBits: 0,\n            hiword: 0,\n            loword: 0,\n            activeCommand: -1,\n            repeatTimeout: 0,\n            onIrDatagram: undefined,\n        };\n        control.inBackground(() => {\n            while (true) {\n                if (irState && irState.activeCommand !== -1 && input.runningTime() > irState.repeatTimeout) {\n                    irState.activeCommand = -1;\n                }\n                basic.pause(REPEAT_TIMEOUT_MS);\n            }\n        });\n    }\n\n    function ir_rec_to16BitHex(value: number): string {\n        let hex = \"\";\n        for (let pos = 0; pos < 4; pos++) {\n            let remainder = value % 16;\n            hex = \"0123456789ABCDEF\".charAt(remainder) + hex;\n            value = Math.idiv(value, 16);\n        }\n        return hex;\n    }\n\n    /**\n     * Initializes the IR receiver module. Connect the sensor to pin P9.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=\"one_bit_ir_init\" block=\"Initialize IR Receiver\"\n    //% weight=90\n    export function initializeIrReceiver(): void {\n        initIrState();\n        if (irState.protocol) return;\n        irState.protocol = 1;\n        enableIrMarkSpaceDetection(DigitalPin.P9);\n    }\n\n    /**\n     * Returns the code of the IR button that was pressed last.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=\"one_bit_ir_button_pressed\" block=\"IR button Values\"\n    //% weight=70\n    export function irButton(): number {\n        basic.pause(0);\n        if (!irState) { return IrButton.Any; }\n        return irState.commandSectionBits >> 8;\n    }\n\n    /**\n     * Do something when an IR datagram is received.\n     * @param handler body code to run when the event is raised\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=\"one_bit_on_ir_datagram\" block=\"on IR datagram received\"\n    //% weight=40\n    export function onIrDatagram(handler: () => void) {\n        initIrState();\n        irState.onIrDatagram = handler;\n    }\n\n    /**\n     * Returns the IR datagram as a 32-bit hexadecimal string.\n     */\n    //% subcategory=\"Sensors\"\n    //% group=\"IR Receiver\"\n    //% blockId=\"one_bit_ir_datagram\" block=\"IR datagram\"\n    //% weight=30\n    export function irDatagram(): string {\n        basic.pause(0);\n        initIrState();\n        return \"0x\" + ir_rec_to16BitHex(irState.addressSectionBits) + ir_rec_to16BitHex(irState.commandSectionBits);\n    }\n\n    // --- LDR Sensor ---\n    /**\n     * Reads LDR digital value (common modules output HIGH for light, LOW for dark).\n     * @param pin Digital pin for LDR sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"LDR Sensor\"\n    //% blockId=\"one_bit_ldr_digital\" block=\"LDR digital value on pin %pin\"\n    //% pin.defl=DigitalPinPrime.P4 weight=65 blockGap=8\n    export function getLDRDigitalValue(pin: DigitalPinPrime): number {\n        pins.setPull(pin as number as DigitalPin, PinPullMode.PullNone);\n        return pins.digitalReadPin(pin as number as DigitalPin);\n    }\n    /**\n     * Check if LDR sensor (digital) detects light.\n     * @param pin Digital pin for LDR sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"LDR Sensor\"\n    //% blockId=\"one_bit_ldr_is_light_digital\" block=\"LDR on pin %pin detects light (digital)\"\n    //% pin.defl=DigitalPinPrime.P4 weight=64 blockGap=8\n    export function isLDRDetectingLight(pin: DigitalPinPrime): boolean {\n        return getLDRDigitalValue(pin) === 1; // Assuming HIGH for light\n    }\n    /**\n     * Reads LDR analog value (raw). Higher value often means MORE light (lower resistance).\n     * @param pin Analog pin for LDR sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"LDR Sensor\"\n    //% blockId=\"one_bit_ldr_analog_raw\" block=\"LDR analog value (lightness) on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P1 weight=63 blockGap=8\n    export function getLDRAnalogRaw(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin as number as AnalogPin);\n    }\n    /**\n     * Reads LDR analog value (inverted for darkness). Higher value means DARKER.\n     * @param pin Analog pin for LDR sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"LDR Sensor\"\n    //% blockId=\"one_bit_ldr_analog_darkness\" block=\"LDR analog value (darkness) on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P1 weight=62 blockGap=20\n    export function getLDRAnalogDarkness(pin: AnalogPinPrime): number {\n        return 1023 - pins.analogReadPin(pin as number as AnalogPin);\n    }\n\n    // --- Moisture Sensor ---\n    let _moistureDryCal = 700; // Default ADC value for \"dry\"\n    let _moistureWetCal = 300; // Default ADC value for \"wet\"\n    /**\n     * Set calibration values for moisture sensor percentage calculation.\n     * @param dryValue ADC reading when sensor is dry (e.g., 700).\n     * @param wetValue ADC reading when sensor is fully wet (e.g., 300).\n     */\n    //% subcategory=\"Sensors\" group=\"Moisture Sensor\"\n    //% blockId=\"one_bit_moisture_calibrate\" block=\"calibrate moisture sensor dry ADC: %dryValue wet ADC: %wetValue\"\n    //% dryValue.defl=700 wetValue.defl=300 weight=60\n    export function calibrateMoistureSensor(dryValue: number, wetValue: number): void {\n        _moistureDryCal = Math.max(0, dryValue);\n        _moistureWetCal = Math.max(0, wetValue);\n    }\n    /**\n     * Reads analog value from moisture sensor. Higher value typically means drier.\n     * @param pin Analog pin for moisture sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"Moisture Sensor\"\n    //% blockId=\"one_bit_moisture_analog\" block=\"moisture sensor analog value on Pin %pin\"\n    //% pin.defl=AnalogPinPrime.P2 weight=58 blockGap=8\n    export function getMoistureSensorValue(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin as number as AnalogPin);\n    }\n    /**\n     * Get moisture level as a percentage (0% very dry, 100% very wet).\n     * Uses calibrated or default dry/wet ADC values.\n     * @param pin Analog pin for moisture sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"Moisture Sensor\"\n    //% blockId=\"one_bit_moisture_percent\" block=\"moisture sensor level on pin %pin (%)\"\n    //% pin.defl=AnalogPinPrime.P2 weight=57 blockGap=8\n    export function getMoisturePercent(pin: AnalogPinPrime): number {\n        let raw = getMoistureSensorValue(pin);\n        // Ensure wet is lower ADC than dry for correct mapping\n        let lowerBound = Math.min(_moistureWetCal, _moistureDryCal);\n        let upperBound = Math.max(_moistureWetCal, _moistureDryCal);\n        // Map so that wetValue -> 100%, dryValue -> 0%\n        let percent = Math.map(raw, upperBound, lowerBound, 0, 100);\n        return Math.clamp(0, 100, Math.round(percent));\n    }\n    /**\n    * Check if soil is \"wet\" based on a threshold percentage.\n    * @param pin Analog pin for moisture sensor.\n    * @param thresholdPercent Wetness threshold in % (e.g., 60).\n    */\n    //% subcategory=\"Sensors\" group=\"Moisture Sensor\"\n    //% blockId=\"one_bit_moisture_is_wet\" block=\"moisture sensor on pin %pin is wet (level > %thresholdPercent|%)\"\n    //% pin.defl=AnalogPinPrime.P2 thresholdPercent.defl=60 weight=56 blockGap=20\n    export function isSoilWet(pin: AnalogPinPrime, thresholdPercent: number): boolean {\n        return getMoisturePercent(pin) > thresholdPercent;\n    }\n\n    // --- Pushbutton & Limit Switch ---\n\n    /**\n     * Checks if a pushbutton/switch is pressed/triggered.\n     * Assumes an active-high circuit (button connects pin to VCC/3.3V).\n     * @param pin Digital pin for the button/switch.\n     */\n    //% subcategory=\"Sensors\" group=\"Switches & Buttons\"\n    //% blockId=\"one_bit_is_switch_pressed\" block=\"switch/button on pin %pin is pressed/triggered\"\n    //% pin.defl=DigitalPinPrime.P13 weight=50 blockGap=8\n    export function isSwitchPressed(pin: DigitalPinPrime): boolean {\n        // Configure with a pull-down resistor to keep the pin LOW when the button is not pressed.\n        pins.setPull(pin as number as DigitalPin, PinPullMode.PullDown);\n        // A press is when the pin reads HIGH (1).\n        return pins.digitalReadPin(pin as number as DigitalPin) === 1;\n    }\n\n    /**\n     * Event when a pushbutton/switch is pressed/triggered (pin goes HIGH).\n     * This block assumes an active-high circuit (button connects pin to VCC/3.3V).\n     * @param pin Digital pin for the button/switch.\n     * @param handler Code to run.\n     */\n    //% subcategory=\"Sensors\" group=\"Switches & Buttons\"\n    //% blockId=\"one_bit_on_switch_pressed\" block=\"on switch/button %pin pressed/triggered\"\n    //% pin.defl=DigitalPinPrime.P13 weight=49\n    export function onSwitchPressed(pin: DigitalPinPrime, handler: () => void) {\n        // Configure with a pull-down resistor.\n        pins.setPull(pin as number as DigitalPin, PinPullMode.PullDown);\n        // Trigger the event when the pin pulses HIGH.\n        pins.onPulsed(pin as number as DigitalPin, PulseValue.High, handler);\n    }\n\n    /**\n     * Event when a pushbutton/switch is released (pin goes LOW).\n     * This block assumes an active-high circuit with a pull-down resistor.\n     * @param pin Digital pin for the button/switch.\n     * @param handler Code to run.\n     */\n    //% subcategory=\"Sensors\" group=\"Switches & Buttons\"\n    //% blockId=\"one_bit_on_switch_released\" block=\"on switch/button %pin released\"\n    //% pin.defl=DigitalPinPrime.P13 weight=48\n    export function onSwitchReleased(pin: DigitalPinPrime, handler: () => void) {\n        // Configure with a pull-down resistor.\n        pins.setPull(pin as number as DigitalPin, PinPullMode.PullDown);\n        // Trigger the event when the pin pulses LOW (is released from HIGH).\n        pins.onPulsed(pin as number as DigitalPin, PulseValue.Low, handler);\n    }\n\n\n    // --- PIR Sensor ---\n    const PIR_EVENT_ID = 3020;\n    const PIR_MOTION_STARTED = 1;\n    const PIR_MOTION_STOPPED = 2;\n    let _pirMonitorPin: DigitalPinPrime = null;\n    let _pirLastState = false;\n\n    function monitorPIR() {\n        if (_pirMonitorPin === null) return;\n        let currentState = isPIRMotionDetected(_pirMonitorPin);\n        if (currentState !== _pirLastState) {\n            _pirLastState = currentState;\n            if (currentState) {\n                control.raiseEvent(PIR_EVENT_ID, PIR_MOTION_STARTED);\n            } else {\n                control.raiseEvent(PIR_EVENT_ID, PIR_MOTION_STOPPED);\n            }\n        }\n    }\n    /**\n     * Checks if PIR sensor detects motion. Assumes sensor outputs HIGH on motion.\n     * @param pin Digital pin for PIR sensor.\n     */\n    //% subcategory=\"Sensors\" group=\"Motion Sensors\"\n    //% blockId=\"one_bit_pir_motion_detected\" block=\"PIR motion detected on pin %pin\"\n    //% pin.defl=DigitalPinPrime.P14 weight=45 blockGap=8\n    export function isPIRMotionDetected(pin: DigitalPinPrime): boolean {\n        pins.setPull(pin as number as DigitalPin, PinPullMode.PullNone);\n        return pins.digitalReadPin(pin as number as DigitalPin) === 1;\n    }\n    /**\n     * Event when PIR sensor starts detecting motion.\n     * @param pin Digital pin for PIR sensor.\n     * @param handler Code to run.\n     */\n    //% subcategory=\"Sensors\" group=\"Motion Sensors\"\n    //% blockId=\"one_bit_on_pir_motion_started\" block=\"on PIR motion started on pin %pin\"\n    //% pin.defl=DigitalPinPrime.P14 weight=44\n    export function onPIRMotionStarted(pin: DigitalPinPrime, handler: () => void) {\n        if (_pirMonitorPin === null) {\n            _pirMonitorPin = pin;\n            _pirLastState = isPIRMotionDetected(pin);\n            control.inBackground(() => { while (true) { monitorPIR(); basic.pause(100); } });\n        } else if (_pirMonitorPin !== pin) {\n            console.warn(\"PIR event already registered on a different pin.\");\n        }\n        control.onEvent(PIR_EVENT_ID, PIR_MOTION_STARTED, handler);\n    }\n    /**\n     * Event when PIR sensor stops detecting motion (pin goes LOW after being HIGH).\n     * @param pin Digital pin for PIR sensor.\n     * @param handler Code to run.\n     */\n    //% subcategory=\"Sensors\" group=\"Motion Sensors\"\n    //% blockId=\"one_bit_on_pir_motion_stopped\" block=\"on PIR motion stopped on pin %pin\"\n    //% pin.defl=DigitalPinPrime.P14 weight=43 blockGap=20\n    export function onPIRMotionStopped(pin: DigitalPinPrime, handler: () => void) {\n        if (_pirMonitorPin === null) {\n            _pirMonitorPin = pin;\n            _pirLastState = isPIRMotionDetected(pin);\n            control.inBackground(() => { while (true) { monitorPIR(); basic.pause(100); } });\n        } else if (_pirMonitorPin !== pin) {\n            console.warn(\"PIR event already registered on a different pin.\");\n        }\n        control.onEvent(PIR_EVENT_ID, PIR_MOTION_STOPPED, handler);\n    }\n\n    // --- Potentiometer ---\n    /**\n     * Reads analog value from potentiometer (0-1023).\n     * @param pin Analog pin for potentiometer.\n     */\n    //% subcategory=\"Sensors\" group=\"Potentiometer\"\n    //% blockId=\"one_bit_potentiometer_raw\" block=\"potentiometer value on pin %pin\"\n    //% pin.defl=AnalogPinPrime.P0 weight=40 blockGap=8\n    export function readPotentiometerValue(pin: AnalogPinPrime): number {\n        return pins.analogReadPin(pin as number as AnalogPin);\n    }\n    /**\n     * Reads potentiometer value as a percentage (0-100%).\n     * @param pin Analog pin for potentiometer.\n     */\n    //% subcategory=\"Sensors\" group=\"Potentiometer\"\n    //% blockId=\"one_bit_potentiometer_percent\" block=\"potentiometer value on pin %pin (percentage)\"\n    //% pin.defl=AnalogPinPrime.P0 weight=39 blockGap=8\n    export function readPotentiometerPercent(pin: AnalogPinPrime): number {\n        return Math.map(pins.analogReadPin(pin as number as AnalogPin), 0, 1023, 0, 100);\n    }\n    /**\n     * Reads potentiometer value and maps it to a custom range.\n     * @param pin Analog pin for potentiometer.\n     * @param toLow Lower bound of target range.\n     * @param toHigh Upper bound of target range.\n     */\n    //% subcategory=\"Sensors\" group=\"Potentiometer\"\n    //% blockId=\"one_bit_potentiometer_map_custom\" block=\"potentiometer on pin %pin mapped to [%toLow-%toHigh]\"\n    //% pin.defl=AnalogPinPrime.P0 toLow.defl=0 toHigh.defl=180\n    //% weight=38 blockGap=20\n    export function readPotentiometerMapped(pin: AnalogPinPrime, toLow: number, toHigh: number): number {\n        return Math.map(pins.analogReadPin(pin as number as AnalogPin), 0, 1023, toLow, toHigh);\n    }\n\n\n    ////////////////////\n    // ACTUATORS      //\n    ////////////////////\n\n    function getResolvedDigitalPin(pin: DigitalPinPrime | PWMPin): DigitalPin {\n        return pin as number as DigitalPin;\n    }\n\n    export enum ServoPosition { /* ... from prev ... */\n        //% block=\"0 degrees\"\n        Zero = 0,\n        //% block=\"45 degrees\"\n        FortyFive = 45,\n        //% block=\"90 degrees\"\n        Ninety = 90,\n        //% block=\"135 degrees\"\n        OneThirtyFive = 135,\n        //% block=\"180 degrees\"\n        OneEighty = 180\n    }\n\n    /** Move servo to a specific angle. */\n    //% subcategory=\"Actuators\" group=\"Positional Servo\"\n    //% blockId=\"one_bit_servo_angle\" block=\"set servo %pin to %angle °\"\n    //% pin.defl=PWMPin.P0 angle.min=0 angle.max=180 angle.defl=90\n    //% weight=100 blockGap=8\n    export function setServoAngle(pin: PWMPin, angle: number): void {\n        pins.servoWritePin(getResolvedDigitalPin(pin), Math.clamp(0, 180, angle));\n    }\n    /** Move servo to a predefined position. */\n    //% subcategory=\"Actuators\" group=\"Positional Servo\"\n    //% blockId=\"one_bit_servo_fixed_pos\" block=\"set servo %pin to %position\"\n    //% pin.defl=PWMPin.P0 weight=98 blockGap=8\n    export function setServoFixedPosition(pin: PWMPin, position: ServoPosition): void {\n        pins.servoWritePin(getResolvedDigitalPin(pin), position);\n    }\n    /** Move servo smoothly between angles. */\n    //% subcategory=\"Actuators\" group=\"Positional Servo\"\n    //% blockId=\"one_bit_servo_smooth_move\" block=\"servo %pin move from %from deg to %to deg over %duration s\"\n    //% pin.defl=PWMPin.P0 from.min=0 from.max=180 to.min=0 to.max=180 duration.min=0.1 duration.defl=1\n    //% weight=96 blockGap=8\n    export function servoSmoothMove(pin: PWMPin, from: number, to: number, duration: number): void {\n        // Implementation from previous response\n        const startAngle = Math.clamp(0, 180, from); const endAngle = Math.clamp(0, 180, to);\n        if (startAngle === endAngle) { pins.servoWritePin(getResolvedDigitalPin(pin), endAngle); return; }\n        const steps = Math.abs(endAngle - startAngle); if (steps === 0) { pins.servoWritePin(getResolvedDigitalPin(pin), endAngle); return; }\n        const stepDuration = (duration * 1000) / steps;\n        for (let i = 0; i <= steps; i++) {\n            const currentAngle = startAngle + (endAngle > startAngle ? i : -i);\n            pins.servoWritePin(getResolvedDigitalPin(pin), Math.clamp(0, 180, currentAngle));\n            if (currentAngle === endAngle) break; basic.pause(stepDuration);\n        }\n        pins.servoWritePin(getResolvedDigitalPin(pin), endAngle);\n    }\n    /** Set servo pulse width directly (μs). */\n    //% subcategory=\"Actuators\" group=\"Positional Servo\"\n    //% blockId=\"one_bit_servo_pulse\" block=\"set servo %pin pulse to %us μs\"\n    //% pin.defl=PWMPin.P0 us.min=500 us.max=2500 us.defl=1500\n    //% weight=94 blockGap=8\n    export function setServoPulse(pin: PWMPin, us: number): void {\n        pins.servoSetPulse(getResolvedDigitalPin(pin), us);\n    }\n    /** Detach servo (stops sending pulses, saves power). */\n    //% subcategory=\"Actuators\" group=\"Positional Servo\"\n    //% blockId=\"one_bit_servo_detach\" block=\"detach servo %pin\"\n    //% pin.defl=PWMPin.P0 weight=92 blockGap=20\n    export function detachServo(pin: PWMPin): void {\n        pins.servoSetPulse(getResolvedDigitalPin(pin), 0);\n    }\n\n    /** Control continuous rotation servo speed. */\n    //% subcategory=\"Actuators\" group=\"Continuous Servo\"\n    //% blockId=\"one_bit_continuous_servo_speed\" block=\"set continuous servo %pin speed to %speed \\\\%\"\n    //% pin.defl=PWMPin.P1 speed.min=-100 speed.max=100 speed.defl=0\n    //% weight=90 blockGap=8\n    export function setContinuousServoSpeed(pin: PWMPin, speed: number): void {\n        const pwmValue = Math.map(Math.clamp(-100, 100, speed), -100, 100, 0, 180);\n        pins.servoWritePin(getResolvedDigitalPin(pin), pwmValue);\n    }\n    /** Stop continuous rotation servo. */\n    //% subcategory=\"Actuators\" group=\"Continuous Servo\"\n    //% blockId=\"one_bit_continuous_servo_stop\" block=\"stop continuous servo %pin\"\n    //% pin.defl=PWMPin.P1 weight=88 blockGap=20\n    export function stopContinuousServo(pin: PWMPin): void {\n        pins.servoWritePin(getResolvedDigitalPin(pin), 90);\n    }\n\n    //% group=\"Motor Driver (L9110S)\"\n\n    /**\n     * Define the direction of motor rotation.\n     */\n    export enum MotorDirection {\n        //% block=\"forward\"\n        Forward,\n        //% block=\"backward\"\n        Backward\n    }\n\n    /**\n     * Controls a single DC motor connected to an L9110S-style driver.\n     * @param pin1 The first control pin for the motor (e.g., INA).\n     * @param pin2 The second control pin for the motor (e.g., INB).\n     * @param direction The direction to rotate the motor.\n     * @param speed The speed of rotation, from 0 to 100.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Motor Driver (L9110S)\"\n    //% block=\"rotate motor pin1 %pin1 pin2 %pin2 direction %direction at speed %speed\"\n    //% pin1.defl=PWMPin.P0\n    //% pin2.defl=PWMPin.P1\n    //% speed.min=0 speed.max=100 speed.defl=50\n    //% weight=100\n    export function controlL9110SMotor(pin1: PWMPin, pin2: PWMPin, direction: MotorDirection, speed: number): void {\n        // Map speed (0-100) to PWM value (0-1023) and ensure it's within bounds.\n        let pwmSpeed = pins.map(\n            Math.clamp(0, 100, speed),\n            0, 100, 0, 1023\n        );\n\n        if (direction === MotorDirection.Forward) {\n            // Apply PWM to pin1 and set pin2 to LOW for forward rotation.\n            pins.analogWritePin(pin1 as number as AnalogPin, pwmSpeed);\n            pins.digitalWritePin(pin2 as number as DigitalPin, 0);\n        } else if (direction === MotorDirection.Backward) {\n            // Set pin1 to LOW and apply PWM to pin2 for backward rotation.\n            pins.digitalWritePin(pin1 as number as DigitalPin, 0);\n            pins.analogWritePin(pin2 as number as AnalogPin, pwmSpeed);\n        }\n    }\n\n    /**\n     * Stops a single DC motor connected to an L9110S-style driver.\n     * @param pin1 The first control pin for the motor.\n     * @param pin2 The second control pin for the motor.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Motor Driver (L9110S)\"\n    //% block=\"stop motor pin1 %pin1 pin2 %pin2\"\n    //% pin1.defl=PWMPin.P0\n    //% pin2.defl=PWMPin.P1\n    //% weight=90\n    export function stopL9110SMotor(pin1: PWMPin, pin2: PWMPin): void {\n        // Set both pins to LOW to brake the motor.\n        pins.digitalWritePin(pin1 as number as DigitalPin, 0);\n        pins.digitalWritePin(pin2 as number as DigitalPin, 0);\n    }\n\n    //% group=\"Onboard RGB\"\n\n    /**\n     * An enum to select one of the two onboard RGB LEDs.\n     */\n    export enum RgbLed {\n        //% block=\"1\"\n        Led1 = 0,\n        //% block=\"2\"\n        Led2 = 1\n    }\n\n    // --- Onboard RGB LED (2 LEDs) ---\n    // Note: This implementation assumes the 2 onboard LEDs are on a single WS2812 data line.\n    // Pin P8 is used as a sensible default.\n    let rgbLedBuffer: Buffer = null;\n    let rgbLedRawColors: number[] = [0, 0]; // Fixed size for 2 LEDs\n    let rgbLedBrightness: number = 255;\n    let rgbLedInitialized = false;\n    const RGB_LED_PIN = DigitalPin.P8;\n\n    /**\n     * Helper function to ensure the RGB LED system is initialized.\n     */\n    function _rgbLedEnsureInitialized() {\n        if (!rgbLedInitialized) {\n            rgbLedBuffer = pins.createBuffer(2 * 3); // 2 LEDs * 3 bytes/color\n            clearRgbLeds(); // Start with LEDs off\n            rgbLedInitialized = true;\n        }\n    }\n\n    /**\n     * Helper function to apply the current brightness to a raw color and write it to the buffer.\n     * @param index The index of the LED (0 or 1).\n     * @param color The raw RGB color number.\n     */\n    function _rgbLedApplyBrightness(index: number, color: number): void {\n        let r = (color >> 16) & 0xFF;\n        let g = (color >> 8) & 0xFF;\n        let b = color & 0xFF;\n        // Apply brightness scaling\n        rgbLedBuffer[index * 3 + 0] = Math.round((g * rgbLedBrightness) / 255); // Green\n        rgbLedBuffer[index * 3 + 1] = Math.round((r * rgbLedBrightness) / 255); // Red\n        rgbLedBuffer[index * 3 + 2] = Math.round((b * rgbLedBrightness) / 255); // Blue\n    }\n\n    /**\n     * Sends the color data in the buffer to the LEDs.\n     */\n    function showRgbLedBuffer(): void {\n        _rgbLedEnsureInitialized();\n        light.sendWS2812Buffer(rgbLedBuffer, RGB_LED_PIN);\n    }\n\n    /**\n     * Sets the color of a specific onboard RGB LED.\n     * @param led The LED to set the color of (1 or 2).\n     * @param color The color to set.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Onboard RGB\"\n    //% block=\"set RGB LED %led to %color\"\n    //% color.shadow=\"one_bit_onboard_rgb_color_picker\"\n    //% weight=100\n    export function setRgbLedColor(led: RgbLed, color: number): void {\n        _rgbLedEnsureInitialized();\n        const index = led as number;\n        rgbLedRawColors[index] = color;\n        _rgbLedApplyBrightness(index, color);\n        showRgbLedBuffer();\n    }\n\n    /**\n     * Sets the color of both onboard RGB LEDs at the same time.\n     * @param color The color to set.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Onboard RGB\"\n    //% block=\"set both RGB LEDs to %color\"\n    //% color.shadow=\"one_bit_onboard_rgb_color_picker\"\n    //% weight=95\n    export function setAllRgbLeds(color: number): void {\n        _rgbLedEnsureInitialized();\n        for (let i = 0; i < 2; i++) {\n            rgbLedRawColors[i] = color;\n            _rgbLedApplyBrightness(i, color);\n        }\n        showRgbLedBuffer();\n    }\n\n    /**\n     * Clears both onboard RGB LEDs, turning them off.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Onboard RGB\"\n    //% block=\"clear RGB LEDs\"\n    //% weight=90\n    export function clearRgbLeds(): void {\n        setAllRgbLeds(0);\n    }\n\n    /**\n     * Gets the current color of a specific onboard RGB LED (ignores brightness).\n     * @param led The LED to get the color from (1 or 2).\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Onboard RGB\"\n    //% block=\"color of RGB LED %led\"\n    //% weight=85\n    export function getRgbLedColor(led: RgbLed): number {\n        _rgbLedEnsureInitialized();\n        return rgbLedRawColors[led as number];\n    }\n\n    /**\n     * Sets the brightness for both onboard RGB LEDs.\n     * @param brightness The brightness level, from 0 to 255.\n     */\n    //% subcategory=\"Actuators\"\n    //% group=\"Onboard RGB\"\n    //% block=\"set RGB brightness to %brightness\"\n    //% brightness.min=0 brightness.max=255 brightness.defl=255\n    //% weight=80\n    export function setRgbBrightness(brightness: number): void {\n        _rgbLedEnsureInitialized();\n        rgbLedBrightness = Math.clamp(0, 255, brightness);\n        // Re-apply the brightness to the stored raw colors\n        for (let i = 0; i < 2; i++) {\n            _rgbLedApplyBrightness(i, rgbLedRawColors[i]);\n        }\n        showRgbLedBuffer();\n    }\n\n    /**\n     * Onboard RGB color picker.\n     */\n    //% subcategory=\"Actuators\" group=\"Onboard RGB\"\n    //% weight=70 blockGap=20 blockId=\"one_bit_onboard_rgb_color_picker\" block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#FF0000\", \"#FFA500\", \"#FFFF00\", \"#7FFF00\", \"#00FF00\", \"#00FFFF\", \"#007FFF\", \"#0000FF\", \"#A000FF\", \"#FF00FF\", \"#FF1493\", \"#A0522D\", \"#FFFFFF\", \"#808080\", \"#000000\"]'\n    export function onboardRgbColorPicker(value: number): number {\n        return value;\n    }\n\n    /**\n     * Get a random color.\n     */\n    //% subcategory=\"Actuators\" group=\"Onboard RGB\"\n    //% blockId=\"one_bit_onboard_rgb_random_color\" block=\"random color\" weight=65\n    export function randomRgbColor(): number {\n        return Math.randomRange(0, 0xFFFFFF);\n    }\n\n    /**\n     * Convert RGB values to a single color number.\n     */\n    //% subcategory=\"Actuators\" group=\"Onboard RGB\"\n    //% blockId=\"one_bit_onboard_rgb_rgb_to_color\" block=\"R %r G %g B %b\" weight=60\n    //% r.min=0 r.max=255 g.min=0 g.max=255 b.min=0 b.max=255\n    export function rgbToColor(r: number, g: number, b: number): number {\n        return (r << 16) | (g << 8) | b;\n    }\n\n    /**\n     * Convert HSL (Hue, Saturation, Luminosity) values to a color number.\n     */\n    //% subcategory=\"Actuators\" group=\"Onboard RGB\"\n    //% blockId=\"one_bit_onboard_rgb_hsl_to_color\" block=\"hue %h saturation %s luminosity %l\" weight=55\n    //% h.min=0 h.max=360 s.min=0 s.max=100 l.min=0 l.max=100\n    export function hslToColor(h: number, s: number, l: number): number {\n        return hslToRgb(h, s, l); // Uses the existing helper function\n    }\n\n\n    // --- OLED Display (SSD1306) ---\n    // (OLED implementation largely from previous response, with additions)\n    let oledFont: Buffer; const SSD1306_ADDRESS = 0x3C;\n    // ... other SSD1306 constants from previous response ...\n    const SSD1306_SETCONTRAST = 0x81; const SSD1306_DISPLAYALLON_RESUME = 0xA4;\n    const SSD1306_NORMALDISPLAY = 0xA6; const SSD1306_INVERTDISPLAY = 0xA7;\n    const SSD1306_DISPLAYOFF = 0xAE; const SSD1306_DISPLAYON = 0xAF;\n    // ...\n    let oledCharX = 0, oledCharY = 0; let oledDisplayWidth = 128, oledDisplayHeightPages = 8;\n    let oledInitialized = false;\n\n    function oledCommand(cmd: number) { pins.i2cWriteBuffer(SSD1306_ADDRESS, pins.createBufferFromArray([0x00, cmd])); }\n    function oledCommands(cmds: number[]) { for (let c of cmds) oledCommand(c); }\n\n    /** Initialize OLED display (128x64 default). */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_init\" block=\"initialize OLED width %width height %height\"\n    //% width.defl=128 height.defl=64 weight=100 blockGap=8\n    export function initOLED(width: number = 128, height: number = 64) {\n        if (oledInitialized && oledDisplayWidth === width && oledDisplayHeightPages * 8 === height) return;\n        oledDisplayWidth = width; oledDisplayHeightPages = height / 8;\n        // Full init sequence from previous code...\n        oledCommands([0xAE, 0xD5, 0x80, 0xA8, height - 1, 0xD3, 0x00, 0x40 | 0x00, 0x8D, 0x14, 0x20, 0x00, 0xA0 | 0x01, 0xC8, 0xDA, height == 64 ? 0x12 : 0x02, 0x81, 0xCF, 0xD9, 0xF1, 0xDB, 0x40, 0xA4, 0xA6, 0xAF]);\n        oledFont = hex`0000000000...`; // Full font data from previous\n        oledFont = hex`00000000003E5B4F5B3E3E6B4F6B3E1C3E7C3E1C183C7E3C181C577D571C1C5E7F5E1C00183C1800FFE7C3E7FF0018241800FFE7DBE7FF30483A060E2629792926407F050507407F05253F5A3CE73C5A7F3E1C1C08081C1C3E7F14227F22145F5F005F5F06097F017F006689956A606060606094A2FFA29408047E040810207E201008082A1C08081C2A08081E101010100C1E0C1E0C30383E3830060E3E0E06000000000000005F00000007000700147F147F14242A7F2A12231308646236495620500008070300001C2241000041221C002A1C7F1C2A08083E080800807030000808080808000060600020100804023E5149453E00427F400072494949462141494D331814127F1027454545393C4A49493141211109073649494936464949291E0000140000004034000000081422411414141414004122140802015909063E415D594E7C1211127C7F494949363E414141227F4141413E7F494949417F090909013E414151737F0808087F00417F41002040413F017F081422417F404040407F021C027F7F0408107F3E4141413E3E4151215E7F09192946264949493203017F01033F4040403F1F2040201F3F4038403F631408146303047804036159494D43007F4141410204081020004141417F04020102044040404040000307080020545478407F284444383844444428384444287F385454541800087E090218A4A49C787F0804047800447D40002040403D007F1028440000417F40007C047804787C080404783844444438FC1824241818242418FC7C08040408485454542404043F44243C4040207C1C2040201C3C4030403C44281028444C9090907C4464544C4400083641000000770000004136080002010204023C2623263C1EA1A161123A4040207A385454555921555579412154547841215554784020545579400C1E5272123955555559395454545939555454580000457C410002457D420001457C40F0292429F0F0282528F07C545545002054547C547C0A097F4932494949323248484832324A4848303A4141217A3A42402078009DA0A07D39444444393D4040403D3C24FF2424487E4943662B2FFC2F2BFF0929F620C0887E090320545479410000447D413048484A32384040227A007A0A0A727D0D19317D2629292F28262929292630484D4020380808080808080808382F10C8ACBA2F102834FA00007B000008142A142222142A1408AA005500AAAA55AA55AA000000FF00101010FF00141414FF001010FF00FF1010F010F0141414FC001414F700FF0000FF00FF1414F404FC141417101F10101F101F101010F0000000001F101010101F10101010F010000000FF101010101010101010FF10000000FF140000FF00FF00001F10170000FC04F414141710171414F404F40000FF00F714141414141414F700F7141414171410101F101F141414F4141010F010F000001F101F0000001F14000000FC140000F010F01010FF10FF141414FF141010101F00000000F010FFFFFFFFFF0F0F0F0F0FFFFFF0000000000FFFF0F0F0F0F0F38444438447C2A2A3E147E02020606027E027E0263554941633844443C04407E201E2006027E020299A5E7A5991C2A492A1C4C7201724C304A4D4D303048784830BC625A463D3E494949007E0101017E2A2A2A2A2A44445F444440514A444040444A51400000FF0103E080FF000008086B6B083612362436060F090F06000018180000001010003040FF0101001F01011E00191D1712003C3C3C3C0000000000`;\n        oledInitialized = true; clearOLED();\n    }\n    function _oledEnsureInit() { if (!oledInitialized) initOLED(); }\n\n    /** Clear OLED display. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_clear\" block=\"OLED clear display\" weight=99 blockGap=8\n    export function clearOLED() {\n        _oledEnsureInit();\n        oledCommand(0x21); oledCommand(0); oledCommand(oledDisplayWidth - 1); // Column addr\n        oledCommand(0x22); oledCommand(0); oledCommand(oledDisplayHeightPages - 1); // Page addr\n        let dataChunk = pins.createBuffer(17); dataChunk[0] = 0x40; // Data mode\n        for (let i = 0; i < oledDisplayWidth * oledDisplayHeightPages; i += 16) {\n            pins.i2cWriteBuffer(SSD1306_ADDRESS, dataChunk);\n        }\n        oledCharX = 0; oledCharY = 0;\n    }\n    /** Turn OLED display ON. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_on\" block=\"OLED turn display ON\" weight=98 blockGap=8\n    export function oledDisplayON() { _oledEnsureInit(); oledCommand(SSD1306_DISPLAYON); }\n    /** Turn OLED display OFF. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_off\" block=\"OLED turn display OFF\" weight=97 blockGap=8\n    export function oledDisplayOFF() { _oledEnsureInit(); oledCommand(SSD1306_DISPLAYOFF); }\n    /** Invert OLED display colors. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_invert\" block=\"OLED invert colors %inverted\" weight=96 blockGap=8\n    //% inverted.shadow=toggleOnOff inverted.defl=true\n    export function oledInvert(inverted: boolean) { _oledEnsureInit(); oledCommand(inverted ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY); }\n    /** Set OLED display contrast. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_contrast\" block=\"OLED set contrast %contrast\" weight=95 blockGap=8\n    //% contrast.min=0 contrast.max=255 contrast.defl=128\n    export function oledSetContrast(contrast: number) { _oledEnsureInit(); oledCommands([SSD1306_SETCONTRAST, Math.clamp(0, 255, contrast)]); }\n\n    function oledSetTextCursor(col: number, rowPage: number) {\n        oledCharX = Math.clamp(0, Math.floor(oledDisplayWidth / 6) - 1, col) * 6;\n        oledCharY = Math.clamp(0, oledDisplayHeightPages - 1, rowPage);\n    }\n    /** Set text cursor position for OLED display. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_set_cursor\" block=\"OLED set text cursor to col %col row %row\"\n    //% col.min=0 col.max=20 row.min=0 row.max=7 weight=94 blockGap=8\n    export function oledSetCursor(col: number, row: number) { _oledEnsureInit(); oledSetTextCursor(col, row); }\n\n    function oledDrawChar(x: number, yPage: number, charCode: number) { /* ... from prev ... */\n        if (x > oledDisplayWidth - 6 || yPage >= oledDisplayHeightPages) return;\n        oledCommands([0x22, yPage, oledDisplayHeightPages - 1, 0x21, x, oledDisplayWidth - 1]); // Set page and col\n        let charData = pins.createBuffer(6); charData[0] = 0x40; // Data mode\n        let fontOffset = charCode * 5;\n        for (let i = 0; i < 5; i++) charData[i + 1] = oledFont.getNumber(NumberFormat.UInt8BE, fontOffset + i);\n        pins.i2cWriteBuffer(SSD1306_ADDRESS, charData); // Char + space\n        charData[1] = 0x00; // Space\n        pins.i2cWriteBuffer(SSD1306_ADDRESS, charData.slice(0, 2));\n    }\n    function oledNewline() { oledCharY++; oledCharX = 0; if (oledCharY >= oledDisplayHeightPages) oledCharY = 0; }\n\n    /** Show string on OLED at current/specified cursor. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_show_string\" block=\"OLED show string %str || at col %x row %y\"\n    //% weight=93 blockGap=8 x.min=0 x.max=20 y.min=0 y.max=7 inlineInputMode=inline\n    export function oledWriteString(str: string, x?: number, y?: number) {\n        _oledEnsureInit();\n        if (x !== undefined && y !== undefined) oledSetTextCursor(x, y);\n        for (let i = 0; i < str.length; i++) {\n            if (oledCharX > oledDisplayWidth - 6) oledNewline();\n            oledDrawChar(oledCharX, oledCharY, str.charCodeAt(i));\n            oledCharX += 6;\n        }\n    }\n    /** Show number on OLED at current/specified cursor. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_show_number\" block=\"OLED show number %n || at col %x row %y\"\n    //% weight=92 blockGap=8 x.min=0 x.max=20 y.min=0 y.max=7 inlineInputMode=inline\n    export function oledWriteNumber(n: number, x?: number, y?: number) { oledWriteString(n.toString(), x, y); }\n\n    // OLED Drawing (Adapted from prev, simplified pixel setting for drawShape)\n    function oledDrawShape(pixels: number[][]): void { /* ... from prev, using oledSetPixel logic if needed or direct buffer writes for lines ... */\n        // For filled shapes, this function would need to be more intelligent or we use line drawing.\n        // The previous oledDrawShape was for sparse pixels.\n        // For lines/rects, directly writing column data is better.\n        // Let's assume drawLine is the primitive.\n    }\n\n    /** Draw line on OLED. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_draw_line\" block=\"OLED draw line from x0 %x0 y0 %y0 to x1 %x1 y1 %y1\"\n    //% x0.min=0 x0.max=127 y0.min=0 y0.max=63 x1.min=0 x1.max=127 y1.min=0 y1.max=63\n    //% weight=91 blockGap=8\n    export function oledDrawLine(x0: number, y0: number, x1: number, y1: number) {\n        _oledEnsureInit();\n        // Bresenham's line algorithm; this function needs to set individual pixels.\n        // This is slow if each pixel is a separate I2C transaction.\n        // A proper implementation would buffer a line and send, or use a screen buffer.\n        // For simplicity, this will be a conceptual placeholder or very slow.\n        // Actual pixel setting on SSD1306 requires setting page/col then writing data.\n        // Let's draw by setting page data.\n        let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        let err = dx + dy, e2;\n        let pageBuf = pins.createBuffer(2); pageBuf[0] = 0x40; // Data mode\n        for (; ;) {\n            // Set pixel at (x0, y0)\n            let page = Math.floor(y0 / 8);\n            let bit = y0 % 8;\n            oledCommands([0x22, page, page, 0x21, x0, x0]); // Set page and col for one pixel\n            // Reading current byte, ORing, then writing is too complex for simple block.\n            // This will just turn the pixel on, possibly affecting others in the same byte.\n            // For true pixel drawing, a screen buffer is best.\n            // For now, only draw \"on\" pixels.\n            pageBuf[1] = (1 << bit); // This overwrites the column. Not ideal.\n            pins.i2cWriteBuffer(SSD1306_ADDRESS, pageBuf);\n\n            if (x0 == x1 && y0 == y1) break;\n            e2 = 2 * err;\n            if (e2 >= dy) { err += dy; x0 += sx; }\n            if (e2 <= dx) { err += dx; y0 += sy; }\n        }\n    }\n    /** Draw rectangle on OLED. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_draw_rect\" block=\"OLED draw rectangle x %x y %y w %w h %h\"\n    //% x.min=0 x.max=127 y.min=0 y.max=63 w.min=1 w.max=128 h.min=1 h.max=64\n    //% weight=90 blockGap=8\n    export function oledDrawRectangle(x: number, y: number, w: number, h: number) {\n        oledDrawLine(x, y, x + w - 1, y); oledDrawLine(x, y, x, y + h - 1);\n        oledDrawLine(x + w - 1, y, x + w - 1, y + h - 1); oledDrawLine(x, y + h - 1, x + w - 1, y + h - 1);\n    }\n    /** Draw filled rectangle on OLED. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_draw_filled_rect\" block=\"OLED draw filled rectangle x %x y %y w %w h %h\"\n    //% x.min=0 x.max=127 y.min=0 y.max=63 w.min=1 w.max=128 h.min=1 h.max=64\n    //% weight=89 blockGap=8\n    export function oledDrawFilledRectangle(x: number, y: number, w: number, h: number) {\n        _oledEnsureInit();\n        for (let i = 0; i < h; i++) {\n            oledDrawLine(x, y + i, x + w - 1, y + i);\n        }\n    }\n    /** Draw circle on OLED. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_draw_circle\" block=\"OLED draw circle x %cx y %cy radius %r\"\n    //% cx.min=0 cx.max=127 cy.min=0 cy.max=63 r.min=1 r.max=63\n    //% weight=88 blockGap=8\n    export function oledDrawCircle(cx: number, cy: number, r: number) {\n        _oledEnsureInit(); // Simplified circle, plots points.\n        let x = r, y = 0, err = 0;\n        let pageBuf = pins.createBuffer(2); pageBuf[0] = 0x40; // Data mode\n        function plot(px: number, py: number) {\n            if (px < 0 || px >= oledDisplayWidth || py < 0 || py >= oledDisplayHeightPages * 8) return;\n            let page = Math.floor(py / 8); let bit = py % 8;\n            oledCommands([0x22, page, page, 0x21, px, px]);\n            pageBuf[1] = (1 << bit); pins.i2cWriteBuffer(SSD1306_ADDRESS, pageBuf);\n        }\n        while (x >= y) {\n            plot(cx + x, cy + y); plot(cx + y, cy + x);\n            plot(cx - y, cy + x); plot(cx - x, cy + y);\n            plot(cx - x, cy - y); plot(cx - y, cy - x);\n            plot(cx + y, cy - x); plot(cx + x, cy - y);\n            if (err <= 0) { y += 1; err += 2 * y + 1; }\n            if (err > 0) { x -= 1; err -= 2 * x + 1; }\n        }\n    }\n    /** Draw filled circle on OLED. */\n    //% subcategory=\"Actuators\" group=\"OLED Display\"\n    //% blockId=\"one_bit_oled_draw_filled_circle\" block=\"OLED draw filled circle x %cx y %cy radius %r\"\n    //% cx.min=0 cx.max=127 cy.min=0 cy.max=63 r.min=1 r.max=63\n    //% weight=87 blockGap=20\n    export function oledDrawFilledCircle(cx: number, cy: number, r: number) {\n        _oledEnsureInit(); // Draws horizontal lines\n        for (let y = -r; y <= r; y++) {\n            for (let x = -r; x <= r; x++) {\n                if (x * x + y * y <= r * r) {\n                    let px = cx + x, py = cy + y;\n                    if (px < 0 || px >= oledDisplayWidth || py < 0 || py >= oledDisplayHeightPages * 8) continue;\n                    let page = Math.floor(py / 8); let bit = py % 8;\n                    let pageBuf = pins.createBuffer(2); pageBuf[0] = 0x40;\n                    oledCommands([0x22, page, page, 0x21, px, px]);\n                    pageBuf[1] = (1 << bit); pins.i2cWriteBuffer(SSD1306_ADDRESS, pageBuf);\n                }\n            }\n        }\n    }\n\n\n    ////////////////////\n    // RAINBOW BLOCKS // \n    ////////////////////\n    let rainbowBuffer: Buffer = null;\n    let rainbowNumLeds: number = 24;\n    let rainbowBrightness: number = 255;\n    let rainbowLastBrightnessApplied: number = 255;\n    let rainbowRawColors: number[] = [];\n\n    /** Initialize Rainbow LED strip. */\n    //% subcategory=\"Rainbow\" group=\"Setup\"\n    //% blockId=\"one_bit_rainbow_initialize\" block=\"initialize Rainbow NeoPixel with %numLeds LEDs\"\n    //% weight=100 blockGap=8 numLeds.defl=24\n    export function initializeRainbow(numLeds: number): void {\n        rainbowNumLeds = Math.max(1, numLeds);\n        rainbowBuffer = control.createBuffer(rainbowNumLeds * 3);\n        rainbowRawColors = []; for (let i = 0; i < rainbowNumLeds; i++) rainbowRawColors.push(0);\n        rainbowBrightness = 255; rainbowLastBrightnessApplied = 255;\n        clearRainbow();\n    }\n    function _rainbowEnsureInitialized() { if (!rainbowBuffer) initializeRainbow(rainbowNumLeds); }\n    function _rainbowApplyBrightnessToRaw(index: number, color: number): void { /* ... similar to prime ... */\n        let r = (color >> 16) & 0xFF; let g = (color >> 8) & 0xFF; let b = color & 0xFF;\n        rainbowBuffer[index * 3 + 0] = Math.round((g * rainbowBrightness) / 255);\n        rainbowBuffer[index * 3 + 1] = Math.round((r * rainbowBrightness) / 255);\n        rainbowBuffer[index * 3 + 2] = Math.round((b * rainbowBrightness) / 255);\n    }\n    function showRainbowBuffer(): void { _rainbowEnsureInitialized(); light.sendWS2812Buffer(rainbowBuffer, DigitalPin.P2); }\n\n    /** Show rainbow colors on Rainbow strip. */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_show_rainbow\" block=\"Rainbow show rainbow\" weight=95\n    export function showRainbow(): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized();\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            let hue = (i * 360) / rainbowNumLeds; const color = hslToRgb(hue, 100, 50);\n            rainbowRawColors[i] = color; _rainbowApplyBrightnessToRaw(i, color);\n        }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Clear Rainbow strip. */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_clear\" block=\"Rainbow clear\" weight=90\n    export function clearRainbow(): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized();\n        for (let i = 0; i < rainbowNumLeds; i++) { rainbowRawColors[i] = 0; _rainbowApplyBrightnessToRaw(i, 0); }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Set all Rainbow LEDs to one color. */\n    //% subcategory=\"Rainbow\" group=\"Display\" value.defl='#ff0000'\n    //% blockId=\"one_bit_rainbow_set_color_all\" block=\"Rainbow set all LEDs to %color\"\n    //% weight=85 color.shadow=\"one_bit_rainbow_color_picker\"\n    export function setRainbowColor(color: number): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized();\n        for (let i = 0; i < rainbowNumLeds; i++) { rainbowRawColors[i] = color; _rainbowApplyBrightnessToRaw(i, color); }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Set specific Rainbow LED to color. */\n    //% subcategory=\"Rainbow\" group=\"Display\" value.defl='#FFFFFF'\n    //% blockId=\"one_bit_rainbow_set_led_color\" block=\"Rainbow set LED at %ledIndex to %color\"\n    //% weight=80 ledIndex.min=0 color.shadow=\"one_bit_rainbow_color_picker\"\n    export function setRainbowLedColor(ledIndex: number, color: number): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized(); if (ledIndex < 0 || ledIndex >= rainbowNumLeds) return;\n        rainbowRawColors[ledIndex] = color; _rainbowApplyBrightnessToRaw(ledIndex, color);\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Get color of specific Rainbow LED (before brightness). */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_get_led_color\" block=\"Rainbow get color of LED at %ledIndex\"\n    //% weight=78 ledIndex.min=0\n    export function getRainbowLedColor(ledIndex: number): number {\n        _rainbowEnsureInitialized(); if (ledIndex < 0 || ledIndex >= rainbowNumLeds) return 0;\n        return rainbowRawColors[ledIndex];\n    }\n    /** Fill a range of Rainbow LEDs. */\n    //% subcategory=\"Rainbow\" group=\"Display\" value.defl='#00FF00'\n    //% blockId=\"one_bit_rainbow_fill_leds\" block=\"Rainbow fill LEDs from %fromIndex to %toIndex with %color\"\n    //% weight=77 color.shadow=\"one_bit_rainbow_color_picker\" fromIndex.min=0 toIndex.min=0\n    export function fillRainbowLeds(fromIndex: number, toIndex: number, color: number): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized(); fromIndex = Math.clamp(0, rainbowNumLeds - 1, fromIndex); toIndex = Math.clamp(0, rainbowNumLeds - 1, toIndex);\n        for (let i = Math.min(fromIndex, toIndex); i <= Math.max(fromIndex, toIndex); i++) { rainbowRawColors[i] = color; _rainbowApplyBrightnessToRaw(i, color); }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Set Rainbow strip brightness. */\n    //% subcategory=\"Rainbow\" group=\"Setup\"\n    //% blockId=\"one_bit_rainbow_set_brightness\" block=\"Rainbow set brightness to %brightness\"\n    //% weight=75 brightness.min=0 brightness.max=255 brightness.defl=255\n    export function setRainbowBrightness(brightness: number): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized(); rainbowBrightness = Math.clamp(0, 255, brightness);\n        for (let i = 0; i < rainbowNumLeds; i++) _rainbowApplyBrightnessToRaw(i, rainbowRawColors[i]);\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Shift Rainbow LEDs. */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_shift_leds\" block=\"Rainbow shift LEDs by %offset positions || wrap around %wrapAround\"\n    //% weight=73 wrapAround.defl=false\n    export function shiftRainbowLeds(offset: number, wrapAround: boolean = false): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized(); if (rainbowNumLeds === 0 || offset === 0) return;\n        offset = offset % rainbowNumLeds; let newRawColors = [];\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            let sourceIndex = i - offset;\n            if (wrapAround) { sourceIndex = (sourceIndex % rainbowNumLeds + rainbowNumLeds) % rainbowNumLeds; newRawColors.push(rainbowRawColors[sourceIndex]); }\n            else { if (sourceIndex >= 0 && sourceIndex < rainbowNumLeds) newRawColors.push(rainbowRawColors[sourceIndex]); else newRawColors.push(0); }\n        }\n        rainbowRawColors = newRawColors;\n        for (let i = 0; i < rainbowNumLeds; i++) _rainbowApplyBrightnessToRaw(i, rainbowRawColors[i]);\n        showRainbowBuffer();\n    }\n    /** Rotate Rainbow LEDs. */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_rotate_leds\" block=\"Rainbow rotate LEDs by %offset positions\"\n    //% weight=72\n    export function rotateRainbowLeds(offset: number): void { shiftRainbowLeds(offset, true); }\n    /** Show gradient on Rainbow strip. */\n    //% subcategory=\"Rainbow\" group=\"Display\"\n    //% blockId=\"one_bit_rainbow_gradient\" block=\"Rainbow show gradient length %length|from %fromColor|to %toColor||start hue %startHue\"\n    //% weight=70 length.defl=24 fromColor.shadow=\"one_bit_rainbow_color_picker\" value.defl=\"#ff0000\" toColor.shadow=\"one_bit_rainbow_color_picker\" value.defl=\"#00ff00\" startHue.min=0 startHue.max=360\n    export function showRainbowGradient(length: number, fromColor: number, toColor: number, startHue?: number): void { /* ... similar to prime ... */\n        _rainbowEnsureInitialized(); length = Math.min(length, rainbowNumLeds); if (length === 0) { showRainbowBuffer(); return; }\n        for (let i = 0; i < length; i++) {\n            let blendFactor = (length <= 1) ? 0 : i / (length - 1); let RblendColor = blend(fromColor, toColor, blendFactor);\n            rainbowRawColors[i] = RblendColor; _rainbowApplyBrightnessToRaw(i, RblendColor);\n        }\n        for (let i = length; i < rainbowNumLeds; i++) { rainbowRawColors[i] = 0; _rainbowApplyBrightnessToRaw(i, 0); }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n\n    /** Rainbow color picker. */\n    //% subcategory=\"Rainbow\" group=\"Color Utilities\"\n    //% weight=65 blockGap=20 blockId=\"one_bit_rainbow_color_picker\" block=\"%value\"\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.colours='[\"#FF0000\", \"#FFA500\", \"#FFFF00\", \"#7FFF00\", \"#00FF00\", \"#00FFFF\", \"#007FFF\", \"#0000FF\", \"#A000FF\", \"#FF00FF\", \"#FF1493\", \"#A0522D\", \"#FFFFFF\", \"#808080\", \"#000000\"]'\n    //% value.fieldOptions.columns=5 value.fieldOptions.className='rgbColorPicker'\n    export function rainbowColorPicker(value: number): number { return value; }\n    /** Get random color for Rainbow. */\n    //% subcategory=\"Rainbow\" group=\"Color Utilities\"\n    //% blockId=\"one_bit_rainbow_random_color\" block=\"Rainbow random color\" weight=60\n    export function rainbowRandomColor(): number { return Math.randomRange(0, 0xFFFFFF); }\n    /** Convert RGB to color for Rainbow. */\n    //% subcategory=\"Rainbow\" group=\"Color Utilities\"\n    //% blockId=\"one_bit_rainbow_rgb_to_color\" block=\"Rainbow R %r G %g B %b\" weight=55\n    //% r.min=0 r.max=255 g.min=0 g.max=255 b.min=0 b.max=255\n    export function rainbowRgbToColor(r: number, g: number, b: number): number { return (r << 16) | (g << 8) | b; }\n    /** Convert HSL to color for Rainbow. */\n    //% subcategory=\"Rainbow\" group=\"Color Utilities\"\n    //% blockId=\"one_bit_rainbow_hsl_to_color\" block=\"Rainbow hue %h saturation %s luminosity %l\" weight=50\n    //% h.min=0 h.max=360 s.min=0 s.max=100 l.min=0 l.max=100\n    export function rainbowHslToColor(h: number, s: number, l: number): number { return hslToRgb(h, s, l); }\n\n    // --- Rainbow Effects --- (Implementations from previous response, ensure they use _rainbowEnsureInitialized and _rainbowApplyBrightnessToRaw where appropriate)\n    function _applyRainbowColorToAll(color: number): void { /* ... from prev, using rainbow fns ... */\n        _rainbowEnsureInitialized();\n        for (let i = 0; i < rainbowNumLeds; i++) { rainbowRawColors[i] = color; _rainbowApplyBrightnessToRaw(i, color); }\n        rainbowLastBrightnessApplied = rainbowBrightness; showRainbowBuffer();\n    }\n    /** Rainbow breathing effect. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_breathing\" block=\"Rainbow breathing effect for %duration s with %color\"\n    //% color.shadow=\"one_bit_rainbow_color_picker\" duration.min=1 duration.defl=5 weight=45\n    export function rainbowBreathingEffect(duration: number, color: number): void { /* ... from prev, adapted for new structure ... */\n        _rainbowEnsureInitialized(); let originalBrightness = rainbowBrightness; let cycleTime = duration * 1000;\n        let halfCycleTime = cycleTime / 2; let steps = 50; let stepTime = halfCycleTime / steps;\n        for (let i = 0; i <= steps; i++) {\n            let currentEffectBrightness = Math.round((i / steps) * 255); // Effect scales full brightness range\n            setRainbowBrightness(Math.round((currentEffectBrightness / 255) * originalBrightness)); // Apply effect relative to original\n            _applyRainbowColorToAll(color); basic.pause(stepTime);\n        }\n        for (let i = steps; i >= 0; i--) {\n            let currentEffectBrightness = Math.round((i / steps) * 255);\n            setRainbowBrightness(Math.round((currentEffectBrightness / 255) * originalBrightness));\n            _applyRainbowColorToAll(color); basic.pause(stepTime);\n        }\n        setRainbowBrightness(originalBrightness); _applyRainbowColorToAll(color);\n    }\n    /** Rainbow color wipe. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_color_wipe\" block=\"Rainbow color wipe %color delay %delay ms\"\n    //% color.shadow=\"one_bit_rainbow_color_picker\" delay.min=10 delay.defl=50 weight=44\n    export function rainbowColorWipe(color: number, delay: number): void { /* ... from prev ... */\n        _rainbowEnsureInitialized();\n        for (let i = 0; i < rainbowNumLeds; i++) {\n            rainbowRawColors[i] = color; _rainbowApplyBrightnessToRaw(i, color);\n            showRainbowBuffer(); basic.pause(delay);\n        }\n        rainbowLastBrightnessApplied = rainbowBrightness;\n    }\n    function wheel(position: number): number { /* ... from prev ... */\n        position = position & 255;\n        if (position < 85) return (((255 - position * 3) & 0xFF) << 16) | (((position * 3) & 0xFF) << 8) | 0;\n        else if (position < 170) { position -= 85; return (0 << 16) | (((255 - position * 3) & 0xFF) << 8) | ((position * 3) & 0xFF); }\n        else { position -= 170; return (((position * 3) & 0xFF) << 16) | (0 << 8) | ((255 - position * 3) & 0xFF); }\n    }\n    /** Rainbow cycle effect. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_cycle\" block=\"Rainbow cycle delay %delay ms for %cycles cycles\"\n    //% delay.min=1 delay.defl=20 cycles.defl=3 weight=43\n    export function rainbowCycle(delay: number, cycles: number): void { /* ... from prev ... */\n        _rainbowEnsureInitialized(); let iterations = 256 * cycles;\n        for (let j = 0; j < iterations; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                const colorVal = wheel(((i * 256) / rainbowNumLeds + j) & 255);\n                rainbowRawColors[i] = colorVal; _rainbowApplyBrightnessToRaw(i, colorVal);\n            }\n            showRainbowBuffer(); basic.pause(delay);\n            if (j % 256 === 0) rainbowLastBrightnessApplied = rainbowBrightness;\n        }\n    }\n    /** Rainbow twinkle effect. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_twinkle\" block=\"Rainbow twinkle %count times with %color on %onDelay ms off %offDelay ms\"\n    //% color.shadow=\"one_bit_rainbow_color_picker\" count.defl=20 onDelay.defl=100 offDelay.defl=100 weight=42\n    export function rainbowTwinkle(count: number, color: number, onDelay: number, offDelay: number): void { /* ... from prev ... */\n        _rainbowEnsureInitialized();\n        for (let k = 0; k < count; k++) {\n            let index = Math.randomRange(0, rainbowNumLeds - 1);\n            let originalColor = rainbowRawColors[index]; // Store to restore later if not black\n            rainbowRawColors[index] = color; _rainbowApplyBrightnessToRaw(index, color); showRainbowBuffer(); basic.pause(onDelay);\n            rainbowRawColors[index] = 0; _rainbowApplyBrightnessToRaw(index, 0); showRainbowBuffer(); basic.pause(offDelay);\n            // Could restore originalColor here if desired, but twinkle usually means off.\n        }\n        rainbowLastBrightnessApplied = rainbowBrightness;\n    }\n    /** Rainbow theater chase. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_theater_chase\" block=\"Rainbow theater chase %color delay %delay ms for %cycles cycles\"\n    //% color.shadow=\"one_bit_rainbow_color_picker\" delay.min=10 delay.defl=50 cycles.defl=10 weight=41\n    export function rainbowTheaterChase(color: number, delay: number, cycles: number): void { /* ... from prev ... */\n        _rainbowEnsureInitialized(); let iterations = cycles * 3;\n        for (let j = 0; j < iterations; j++) {\n            for (let q = 0; q < 3; q++) {\n                for (let i = 0; i < rainbowNumLeds; i = i + 3) if (i + q < rainbowNumLeds) { rainbowRawColors[i + q] = color; _rainbowApplyBrightnessToRaw(i + q, color); }\n                showRainbowBuffer(); basic.pause(delay);\n                for (let i = 0; i < rainbowNumLeds; i = i + 3) if (i + q < rainbowNumLeds) { rainbowRawColors[i + q] = 0; _rainbowApplyBrightnessToRaw(i + q, 0); }\n            }\n            if (j % 3 === 0) rainbowLastBrightnessApplied = rainbowBrightness;\n        }\n    }\n    /** Rainbow wave effect. */\n    //% subcategory=\"Rainbow\" group=\"Effects\"\n    //% blockId=\"one_bit_rainbow_wave\" block=\"Rainbow wave effect %color delay %delay ms for %cycles cycles\"\n    //% color.shadow=\"one_bit_rainbow_color_picker\" delay.min=10 delay.defl=50 cycles.defl=5 weight=40\n    export function rainbowWave(color: number, delay: number, cycles: number): void { /* ... from prev, using hsl for wave ... */\n        _rainbowEnsureInitialized();\n        let rBase = (color >> 16) & 0xFF; let gBase = (color >> 8) & 0xFF; let bBase = color & 0xFF;\n        let iterations = Math.round(2 * Math.PI / 0.1) * cycles; // 0.1 is step, make it run a few cycles\n        for (let j = 0; j < iterations; j++) {\n            for (let i = 0; i < rainbowNumLeds; i++) {\n                let factor = (Math.sin((i / (rainbowNumLeds / 2) + j * 0.1) * Math.PI) + 1) / 2; // Sine wave for brightness factor\n                let r = Math.round(rBase * factor); let g = Math.round(gBase * factor); let b = Math.round(bBase * factor);\n                let waveColor = (r << 16) | (g << 8) | b;\n                rainbowRawColors[i] = waveColor; _rainbowApplyBrightnessToRaw(i, waveColor);\n            }\n            showRainbowBuffer(); basic.pause(delay);\n            if (j % Math.round(2 * Math.PI / 0.1) === 0) rainbowLastBrightnessApplied = rainbowBrightness;\n        }\n    }\n\n}"}]}],"snapshots":[{"timestamp":1751779001598,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Onebit Blocks\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1751779218108}